/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/index.js":
/*!**********************!*\
  !*** ./app/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var _src_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/app */ \"./app/src/app.js\");\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.css */ \"./app/index.css\");\n\n\n\n\nreact_dom__WEBPACK_IMPORTED_MODULE_1__.render( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_src_app__WEBPACK_IMPORTED_MODULE_2__[\"default\"], null), document.getElementById('app'));\n\n//# sourceURL=webpack://webpack-demo/./app/index.js?");

/***/ }),

/***/ "./app/src/app.js":
/*!************************!*\
  !*** ./app/src/app.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _assets_manzara_jpg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/manzara.jpg */ \"./app/src/assets/manzara.jpg\");\n/* harmony import */ var _components_HelloWorld__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/HelloWorld */ \"./app/src/components/HelloWorld.js\");\n\n\nvar App = function App() {\n  return /*#__PURE__*/React.createElement(\"div\", null, \"App Dosyas\\u0131\", /*#__PURE__*/React.createElement(_components_HelloWorld__WEBPACK_IMPORTED_MODULE_1__[\"default\"], null));\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);\n\n//# sourceURL=webpack://webpack-demo/./app/src/app.js?");

/***/ }),

/***/ "./app/src/components/HelloWorld.js":
/*!******************************************!*\
  !*** ./app/src/components/HelloWorld.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helper */ \"./app/src/helper/index.js\");\n\n\nvar HelloWorld = function HelloWorld() {\n  _helper__WEBPACK_IMPORTED_MODULE_1__[\"default\"].deneme();\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", null, \"Hello World\");\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HelloWorld);\n\n//# sourceURL=webpack://webpack-demo/./app/src/components/HelloWorld.js?");

/***/ }),

/***/ "./app/src/helper/index.js":
/*!*********************************!*\
  !*** ./app/src/helper/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar Helper = {\n  test: function test() {\n    console.log('test');\n  },\n  deneme: function deneme() {\n    console.log('deneme');\n  }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Helper);\n\n//# sourceURL=webpack://webpack-demo/./app/src/helper/index.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://webpack-demo/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://webpack-demo/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function _typeof(o){\"@babel/helpers - typeof\";return _typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&\"function\"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?\"symbol\":typeof o;},_typeof(o);}if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var Scheduler=__webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\nfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n// update consoleWithStackDev.www.js as well.\n{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\nvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\nargsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n// breaks IE9: https://github.com/facebook/react/issues/13610\n// eslint-disable-next-line react-internal/no-production-logging\nFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\nvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\nvar enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing\n// the react-reconciler package.\nvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\nvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\nvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\nvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n// and client rendering, mostly to allow JSX attributes to apply to the custom\n// element's object properties instead of only HTML attributes.\n// https://github.com/facebook/react/issues/11347\nvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\nvar warnAboutStringRefs=false;// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\nvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\nvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nvar allNativeEvents=new Set();/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\nfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\nvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n// happened: you supplied an object or symbol value to React (as a prop, key,\n// DOM attribute, CSS property, string ref, etc.) and when React tried to\n// coerce it to a string using `'' + value`, an exception was thrown.\n//\n// The most common types that will cause this exception are `Symbol` instances\n// and Temporal objects like `Temporal.Instant`. But any object that has a\n// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n// exception. (Library authors do this to prevent users from using built-in\n// numeric operators like `+` or comparison operators like `>=` because custom\n// methods are needed to perform accurate arithmetic or comparison.)\n//\n// To fix the problem, coerce this object or symbol value to a string before\n// passing it to React. The most reliable way is usually `String(value)`.\n//\n// To find which value is throwing, check the browser or debugger console.\n// Before this exception was thrown, there should be `console.error` output\n// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n// problem and how that type was used: key, atrribute, input value prop, etc.\n// In most cases, this console output also shows the component and its\n// ancestor components where the exception happened.\n//\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the filter are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\nvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML attribute filter.\n// Some of these attributes can be hard to find. This list was created by\n// scraping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\nfalse);});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\nfalse);});// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\nfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\ntrue,// sanitizeURL\ntrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the\n// react-internal/safe-string-coercion rule is disabled in several spots\n// below.\n{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n// the hydration is successful of a javascript: URL, we\n// still want to warn on the client.\n// eslint-disable-next-line react-internal/safe-string-coercion\nsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\nif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n// and we won't require Trusted Type here.\nattributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\n{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE=Symbol[\"for\"]('react.element');var REACT_PORTAL_TYPE=Symbol[\"for\"]('react.portal');var REACT_FRAGMENT_TYPE=Symbol[\"for\"]('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol[\"for\"]('react.strict_mode');var REACT_PROFILER_TYPE=Symbol[\"for\"]('react.profiler');var REACT_PROVIDER_TYPE=Symbol[\"for\"]('react.provider');var REACT_CONTEXT_TYPE=Symbol[\"for\"]('react.context');var REACT_FORWARD_REF_TYPE=Symbol[\"for\"]('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol[\"for\"]('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol[\"for\"]('react.suspense_list');var REACT_MEMO_TYPE=Symbol[\"for\"]('react.memo');var REACT_LAZY_TYPE=Symbol[\"for\"]('react.lazy');var REACT_SCOPE_TYPE=Symbol[\"for\"]('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol[\"for\"]('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol[\"for\"]('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol[\"for\"]('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol[\"for\"]('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol[\"for\"]('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||_typeof(maybeIterable)!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\nvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\ntry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\nreturn'\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\nif(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\nError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n// for warnings.\nReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\nif(construct){// Something should be setting the props in the constructor.\nvar Fake=function Fake(){throw Error();};// $FlowFixMe\nObject.defineProperty(Fake.prototype,'props',{set:function set(){// We use a throwing setter instead of frozen or non-writable props\n// because that won't throw in a non-strict mode function.\nthrow Error();}});if((typeof Reflect===\"undefined\"?\"undefined\":_typeof(Reflect))==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n// frames added by the construct call.\ntry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\nif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n// Skipping one frame that we assume is the frame that calls the two.\nvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n// Typically this will be the root most one. However, stack frames may be\n// cut off due to maximum stack limits. In this case, one maybe cut off\n// earlier than the other. We assume that the sample is longer or the same\n// and there for cut off earlier. So we should find the root most frame in\n// the sample somewhere in the control.\nc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n// frame that called our sample function and the control.\nif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n// If we're about to return the first line, and the control is also on the same\n// line, that's a pretty good indicator that our sample threw at same line as\n// the control. I.e. before we entered the sample frame. So we ignore this result.\n// This can happen if you passed a class to function component, or non-function.\nif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n// The next one that isn't the same should be our match though.\nif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\nvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n// but we have a user-provided \"displayName\"\n// splice it in to make the stack more readable.\nif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\nreturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\nvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node[\"return\"];}while(node);return info;}catch(x){return'\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\nreturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\nfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\nreturn type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\nreturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\nreturn'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:\ncase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value){// The coercion safety check is performed in getToStringValue().\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function getToStringValue(value){switch(_typeof(value)){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n// eslint-disable-next-line\nnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n// blank-text buttons.\nnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n// properties:\n//  1. The value React property\n//  2. The defaultValue React property\n//  3. Otherwise there should be no change\nif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n// to be removed, such as transitioning from a checkbox into a text input\nif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n// default value provided by the browser. See: #12872\nif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){{// When syncing the value attribute, the value property should use\n// the wrapperState._initialValue property. This uses:\n//\n//   1. The value React property when present\n//   2. The defaultValue React property when present\n//   3. An empty string\nif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n// so we assign defaultValue to the same thing as the value property\n// assignment step above.\nnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n// attribute are assigned at the same time using defaultChecked. This uses:\n//\n//   1. The checked React property when present\n//   2. The defaultChecked React property when present\n//   3. Otherwise, false\nnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\n{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\nif(props.value==null){if(_typeof(props.children)==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\nif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\nfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp */ /**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nreusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\nvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function warnValidStyle(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function camelize(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function warnHyphenatedStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n// is converted to lowercase `ms`.\ncamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function warnValidStyle(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n */ /**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(_typeof(props.dangerouslySetInnerHTML)!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&_typeof(props.style)!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this list too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',\"class\":'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',\"default\":'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',\"for\":'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',\"in\":'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',\"typeof\":'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',_typeof(value));warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nerror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\nif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n// will result in endless cycles like an infinite loop.\n// We also don't want to defer during event replaying.\nvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n// and DOMPluginEventSystem.\nvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\nif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar batchedUpdatesImpl=function batchedUpdatesImpl(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function flushSyncImpl(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n// TODO: Restore state in the microtask, after the discrete updates flush,\n// instead of early flushing them here.\nflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\nfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\nreturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+_typeof(listener)+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\nObject.defineProperty(options,'passive',{get:function get(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// unintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebook/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\nif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Keeps track of the value of window.event so that we can reset it\n// during the callback to let user code access window.event in the\n// browsers that support it.\nvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n// dispatching: https://github.com/facebook/react/issues/13688\nvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n// window.event assignment in both IE <= 10 as they throw an error\n// \"Member not found\" in strict mode, and in Firefox which does not\n// support window.event.\nif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n// Browsers silence the error report if this happens.\n// We'll remember this to later decide whether to log it or not.\nif(error!=null&&_typeof(error)==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n}}}}// Create a fake event type.\nvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\nwindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n// https://github.com/facebook/react/issues/16734\n// https://github.com/facebook/react/issues/16585\n// Fall back to the production implementation.\nrestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\nvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function onError(error){hasError=true;caughtError=error;}};/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\nvar Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\nvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\nvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\nvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\nvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\nvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n// mounted fiber is the parent but we need to continue to figure out\n// if that one is still mounted.\nnearestMounted=node[\"return\"];}nextNode=node[\"return\"];}while(nextNode);}else{while(node[\"return\"]){node=node[\"return\"];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a[\"return\"];if(parentA===null){// We're at the root.\nbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n// happens when a Suspense component is hidden. An extra fragment fiber\n// is inserted in between the Suspense fiber and its children. Skip\n// over this extra fragment fiber and proceed to the next parent.\nvar nextParent=parentA[\"return\"];if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\nthrow new Error('Unable to find node on an unmounted component.');}if(a[\"return\"]!==b[\"return\"]){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\nif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n// This gives DevTools a way to feature detect that isn't tied to version number\n// (since profiling and timeline are controlled by different feature flags).\ninternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\ninjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\nreturn true;}else{// This is likely a hook installed by Fast Refresh runtime.\nreturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n// in SchedulerMock. To reduce the noise in strict mode tests,\n// suppress warnings and disable scheduler yielding during the double render\nunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\nfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\nvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\nvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nfunction getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\nreturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\nvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n// even if the work is suspended.\nvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.\nvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n// TODO: Consider warning in this path if a fallback timer is not scheduled.\nreturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n// it and we'll lose our progress. We should only do this if the new lanes are\n// higher priority.\nif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n// bother waiting until the root is complete.\n(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n// one. This works because the bits decrease in priority as you go left.\nnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n// only difference between default updates and transition updates is that\n// default updates do not support refresh transitions.\nnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\nreturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n// and default updates, so they render in the same batch. The only reason\n// they use separate lanes is because continuous updates should interrupt\n// transitions, but default updates should not.\nnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n//\n// A lane is said to be entangled with another when it's not allowed to render\n// in a batch that does not also include the other lane. Typically we do this\n// when multiple updates have the same source, and we only want to respond to\n// the most recent event from that source.\n//\n// Note that we apply entanglements *after* checking for partial work above.\n// This means that if a lane is entangled during an interleaved event while\n// it's already rendering, we won't interrupt it. This is intentional, since\n// entanglement is usually \"best effort\": we'll try our best to render the\n// lanes in the same batch, but it's not worth throwing out partially\n// completed work in order to do it.\n// TODO: Reconsider this. The counter-argument is that the partial work\n// represents an intermediate state, which we don't want to show to the user.\n// And by spending extra time finishing it, we're increasing the amount of\n// time it takes to show the final state, which is what they are actually\n// waiting for.\n//\n// For those exceptions where entanglement is semantically important, like\n// useMutableSource, we should ensure that there is no partial work at the\n// time we apply the entanglement.\nvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n//\n// NOTE: This is set to the corresponding constant as in Scheduler.js.\n// When we made it larger, a product metric in www regressed, suggesting\n// there's a user interaction that's being starved by a series of\n// synchronous updates. If that theory is correct, the proper solution is\n// to fix the starvation. However, this scenario supports the idea that\n// expiration times are an important safeguard when starvation\n// does happen.\nreturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n// too long, but when I made this change it caused a spike in browser\n// crashes. There must be some other underlying bug; not super urgent but\n// ideally should figure out why and fix it. Unfortunately we don't have\n// a repro for the crashes, only detected via production metrics.\nreturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\nreturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n// the earliest expiration time on the root. Then use that to quickly bail out\n// of this function.\nvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n// expiration time. If so, we'll assume the update is being starved and mark\n// it as expired to force it to finish.\nvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n// using the current time.\nif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\nexpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\nroot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n// expire after a render has already started.\nreturn(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n// In most cases, this means every transition gets its own lane, until we\n// run out of lanes and cycle back to the beginning.\nvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n// doesn't matter which bit is selected; you can pick any bit without\n// affecting the algorithms where its used. Here I'm using\n// getHighestPriorityLane because it requires the fewest operations.\nreturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\nreturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n// https://v8.dev/blog/elements-kinds#avoid-creating-holes\nvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n// could unblock them. Clear the suspended lanes so that we can try rendering\n// them again.\n//\n// TODO: We really only need to unsuspend only lanes that are in the\n// `subtreeLanes` of the updated fiber, or the update lanes of the return\n// path. This would exclude suspended updates in an unrelated sibling tree,\n// since there's no way for this update to unblock it.\n//\n// We don't do this if the incoming update is idle, because we never process\n// idle updates until after all the regular updates have finished; there's no\n// way it could unblock a transition.\nif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\nvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\nroot.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\nvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n// have to consider _transitive_ entanglements. For each lane that is already\n// entangled with *any* of the given lanes, that lane is now transitively\n// entangled with *all* the given lanes.\n//\n// Translated: If C is entangled with A, then entangling A with B also\n// entangles C with B.\n//\n// If this is hard to grasp, it might help to intentionally break this\n// function and look at the tests that fail in ReactTransition-test.js. Try\n// commenting out one of the conditions below.\nvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\nlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\nentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n// be retried at a hydration lane.\nlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n// already attempted and failed to hydrate at that level. Also check if we're\n// already rendering that lane, which is rare but could happen.\nif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\nreturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\nvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\nvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n// if the last target was dehydrated.\nvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\nvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\nvar queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers[\"delete\"](pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures[\"delete\"](_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.\nattemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n// the different event systems have different DOM event listeners.\n// We can accumulate the flags, and the targetContainers, and\n// store a single event to be replayed.\nexistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n// moved from outside the window (no target) onto the target once it hydrates.\n// Instead of mutating we could clone the event.\nswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n// Try to unify them. It's a bit tricky since it would require two return\n// values.\nvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n// Increase its priority.\nqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n// a root other than sync.\nreturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React\n// event system but not native events. Should read window.event.type, like\n// we do for updates (getCurrentEventPriority).\nvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\nif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else{// We're still blocked. Try again later.\nvar _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\ntargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map[\"delete\"](key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n// now unblocked. This first might not actually be unblocked yet.\n// We could check it early to avoid scheduling an unnecessary callback.\nScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n// and eligible for a replay.\nif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n// worth it because we expect very few discrete events to queue up and once\n// we are actually fully unblocked it will be fast to replay them.\nfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function unblock(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\nbreak;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\nqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\nvar _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.\n// We'd like to remove this but it's not clear if this is safe.\nfunction setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n// queueing is accumulative.\nclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n// in case the event system needs to trace it.\ndispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\nreturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\ntargetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n// don't want this event dispatched twice through the event system.\n// TODO: If this is the first discrete event in the queue. Schedule an increased\n// priority for this boundary.\nreturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n// the whole system, dispatch the event without a target.\n// TODO: Warn.\ntargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n// the whole system.\nreturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\nreturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\ncase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n// eslint-disable-next-line no-fallthrough\ncase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n// eslint-disable-next-line no-fallthrough\ncase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n// Eventually this mechanism will be replaced by a check\n// of the current priority on the native scheduler.\nvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\nreturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n// If we had a single constructor, it would be megamorphic and engines would deopt.\nfunction createSyntheticEvent(Interface){/**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */persist:function persist(){// Modern event system doesn't use pooling.\n},/**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function relatedTarget(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function movementX(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function movementY(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n// because it's guaranteed to have already run when movementX\n// was copied.\nreturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */ // Happens to share the same list for now.\nvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n// getModifierState. If getModifierState is not supported, we map it to a set of\n// modifier keys exposed by the event. In this case, Lock-keys are not supported.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(_typeof(detail)==='object'&&'data'in detail){return detail.data;}return null;}/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to ignore it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case'keypress':/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent[\"char\"]&&nativeEvent[\"char\"].length>1){return nativeEvent[\"char\"];}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\nenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n// the event in the out event of the other target. If this is replayed,\n// then it's because we couldn't dispatch against this target previously\n// so we have to do it now instead.\nvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n// already dispatched the corresponding events during its mouseout.\nif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn;}var win;// TODO: why is this nullable in the types but we read from it?\nif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n// the first ancestor. Next time, we will ignore the event.\nvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(_typeof(objA)!=='object'||objA===null||_typeof(objB)!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\nfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n// fails when pasting 100+ items)\nif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n// to throw, e.g. if it has a cross-origin src attribute.\n// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n// iframe.contentDocument.defaultView;\n// A safety way is to access one of the cross origin properties: Window or Location\n// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\nreturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */ /**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Get document associated with the event target.\n */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\ncase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\ncase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n//\n// E.g. it needs \"pointerDown\", not \"pointerdown\".\n// This is because we derive both React name (\"onPointerDown\")\n// and DOM name (\"pointerdown\") from the same list.\n//\n// Exceptions that don't match this convention are listed separately.\n//\n// prettier-ignore\nvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\nregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n// In the past, React has always bubbled them, but this can be surprising.\n// We're going to try aligning closer to the browser behavior by not bubbling\n// them in React either. We'll start by not bubbling onScroll, and then expand.\nvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n// nonDelegatedEvents list in DOMPluginEventSystem.\n// Then we can remove this special list.\n// This is a breaking change that can wait until React 18.\ndomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\nvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\nregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n// This is the basic functionality of the event system. All\n// the other plugins are essentially polyfills. So the plugin\n// should probably be inlined somewhere and have its logic\n// be core the to event system. This would potentially allow\n// us to ship builds of React without the polyfilled plugins below.\nextractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n// event's native \"bubble\" phase, which means that we're\n// not in the capture phase. That's because we emulate\n// the capture phase here still. This is a trade-off,\n// because in an ideal world we would not emulate and use\n// the phases properly, like we do with the SimpleEvent\n// plugin. However, the plugins below either expect\n// emulation (EnterLeave) or use state localized to that\n// plugin (BeforeInput, Change, Select). The state in\n// these modules complicates things, as you'll essentially\n// get the case where the capture phase event might change\n// state, only for the following bubble event to come in\n// later and not trigger anything as the state now\n// invalidates the heuristics of the event plugin. We\n// could alter all these plugins to work in such ways, but\n// that might cause other unknown side-effects that we\n// can't foresee right now.\nif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\nvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n}// This would be a good time to rethrow if any of the event handlers threw.\nrethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\nvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n// doesn't bubble and needs to be on the document.\nif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n// but it is attached to the document.\nif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n// active and not passive.\nvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n// passive by default on document. React doesn't bind them\n// to document anymore, but changing this now would undo\n// the performance wins from the change. So we emulate\n// the existing behavior manually on the roots now.\n// https://github.com/facebook/react/issues/19651\nif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we\nif(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\nif(targetInst!==null){// The below logic attempts to work out if we need to change\n// the target fiber to a different ancestor. We had similar logic\n// in the legacy event system, except the big difference between\n// systems is that the modern event system now has an event listener\n// attached to each React Root and React Portal Root. Together,\n// the DOM nodes representing these roots are the \"rootContainer\".\n// To figure out which ancestor instance we should use, we traverse\n// up the fiber tree from the target instance and attempt to find\n// root boundaries that match that of our current \"rootContainer\".\n// If we find that \"rootContainer\", we find the parent fiber\n// sub-tree for that root and make that our ancestor instance.\nvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n// Normally portals handle their own events all the way down to the root.\n// So we should be able to stop now. However, we don't know if this portal\n// was part of *our* root.\nvar grandNode=node[\"return\"];while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n// a parent of the Portal. That means we can ignore it because the\n// Portal will bubble through to us.\nreturn;}}grandNode=grandNode[\"return\"];}}// Now we need to find it's corresponding host fiber in the other\n// tree. To do this we can use getClosestInstanceFromNode, but we\n// need to validate that the fiber is a host instance, otherwise\n// we need to traverse up through the DOM till we find the correct\n// node that is from the other tree.\nwhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node[\"return\"];}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\nif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n// continue to propagate through the React fiber tree to find other\n// listeners.\nif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\ninstance=instance[\"return\"];}return listeners;}// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance[\"return\"];}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst[\"return\"];// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance[\"return\"];}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\ndialog:true,// Electron ships a custom <webview> tag to display external web content in\n// an isolated frame and process.\n// This tag is not present in non Electron environments such as JSDom which\n// is often used for testing purposes.\n// @see https://electronjs.org/docs/api/webview-tag\nwebview:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n// browsers. It adds spaces and sorts the properties in some\n// non-alphabetical order. Handling that would require sorting CSS\n// properties in the client & server versions or applying\n// `expectedStyle` to a temporary DOM node to read its `style` attribute\n// normalized. Since it only affects IE, we're skipping style warnings\n// in that browser completely in favor of doing all that work.\n// See https://github.com/facebook/react/issues/11807\ncanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,_typeof(listener));}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n// client rendering, up to the nearest Suspense boundary.\nthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\nif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n// attributes on `select`s needs to be added before `option`s are inserted.\n// This prevents:\n// - a bug where the `select` does not scroll to the correct option because singular\n//  `select` elements automatically pick the first item #13222\n// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n// See https://github.com/facebook/react/issues/13222\n// and https://github.com/facebook/react/issues/14239\nif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n// it is possible that no option is selected.\n//\n// This is only necessary when a select in \"single selection mode\".\nnode.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the allowed property list in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the allowed property list during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function validateDOMNesting(){};var updatedAncestorInfo=function updatedAncestorInfo(){};{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function updatedAncestorInfo(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\nvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback)[\"catch\"](handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\nfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\nfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n// If something inside a portal is clicked, that click should bubble\n// through the React tree. However, on Mobile Safari the click would\n// never bubble through the *DOM* tree unless an ancestor with onclick\n// event exists. So we wouldn't see it and dispatch it.\n// This is why we ensure that non React root containers have inline onclick\n// defined.\n// https://github.com/facebook/react/issues/11918\nvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n// pass host context to this method?\ninstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------\nfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a suspense node.\nreturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return{message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};\n// const nextSibling = instance.nextSibling;\n// if (nextSibling) {\n//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;\n//   value.message = dataset.msg;\n//   value.hash = dataset.hash;\n//   if (true) {\n//     value.stack = dataset.stack;\n//   }\n// }\n// return value;\n}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\nfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\nreturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n// able to remove it.\nerror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n// these fields are relevant.\ndelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\nreturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n// to see if one of its parents is a React owned DOM node.\nvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n// React nodes in the future. We need to check this first because\n// if we're a child of a dehydrated container, we need to first\n// find that inner container before moving on to finding the parent\n// instance. Note that we don't check this field on  the targetNode\n// itself because the fibers are conceptually between the container\n// node and the first child. It isn't surrounding the container node.\n// If it's not a container, we check if it's an instance.\ntargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n// stepped past dehydrated DOM nodes to get here. However they could\n// also have been non-React nodes. We need to answer which one.\n// If we the instance doesn't have any children, then there can't be\n// a nested suspense boundary within it. So we can use this as a fast\n// bailout. Most of the time, when people add non-React children to\n// the tree, it is using a ref to a child-less DOM node.\n// Normally we'd only need to check one of the fibers because if it\n// has ever gone from having children to deleting them or vice versa\n// it would have deleted the dehydrated boundary nested inside already.\n// However, since the HostRoot starts out with an alternate it might\n// have one on the alternate so we need to check in case this was a\n// root.\nvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n// nested within a dehydrated boundary and if so, which one.\nvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n// hydrated it yet. Even though we leave the comments in the\n// DOM after hydrating, and there are boundaries in the DOM\n// that could already be hydrated, we wouldn't have found them\n// through this pass since if the target is hydrated it would\n// have had an internalInstanceKey on it.\n// Let's get the fiber associated with the SuspenseComponent\n// as the deepest instance.\nvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n// we haven't gotten to hydrate it yet. There might still be a\n// parent boundary that hasn't above this one so we need to find\n// the outer most that is known.\nsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n// host component also hasn't hydrated yet. We can return it\n// below since it will bail out on the isMounted check later.\n}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\nthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\nvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n// fail the render phase where it didn't fail before. So we log it.\n// After these have been cleaned up, we'll let them throw.\ntry{// This is intentionally an invariant that gets caught. It's the same\n// behavior as without this statement except with a better message.\nif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\nvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+_typeof(typeSpecs[typeSpecName])+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,_typeof(error$1));setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n// same error.\nloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n// we may have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\nif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node[\"return\"];}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\nif(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because\n// we already scheduled one when we created the queue.\nsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n// it might make more sense for the queue to be a list of roots instead of a\n// list of generic callbacks. Then we can have two: one for legacy roots, one\n// for concurrent roots. And this method would only flush the legacy ones.\nif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\nisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n// queue is in the render or commit phases.\nsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\nif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\nscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n// fibers, because that's the only place where we know how many children in\n// the whole set without doing extra work later, or storing addtional\n// information on the fiber.\n//\n// That's why this function is separate from pushTreeId — it's called during\n// the render phase of the fork parent, not the child, which is where we push\n// the other context values.\n//\n// In the Fizz implementation this is much simpler because the child is\n// rendered in the same callstack as the parent.\n//\n// It might be better to just add a `forks` field to the Fiber type. It would\n// make this module simpler.\nwarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n// of the id; we use it to account for leading 0s.\nvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n// consideration the leading 1 we use to mark the end of the sequence.\nif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n// This branch assumes the length of the base id is greater than 5; it won't\n// work for smaller ids, because you need 5 bits per character.\n//\n// We encode the id in multiple steps: first the base id, then the\n// remaining digits.\n//\n// Each 5 bit sequence corresponds to a single base 32 character. So for\n// example, if the current id is 23 bits long, we can convert 20 of those\n// bits into a string of 4 characters, with 3 bits left over.\n//\n// First calculate how many bits in the base id represent a complete\n// sequence of characters.\nvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\nvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\nvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\nvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n// we made more room, this time it won't overflow.\nvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path\nvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n// in its children.\nvar returnFiber=workInProgress[\"return\"];if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n// This is a bit more complicated than other context-like modules in Fiber\n// because the same Fiber may appear on the stack multiple times and for\n// different reasons. We have to keep popping until the work-in-progress is\n// no longer at the top of the stack.\nwhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches\n// due to earlier mismatches or a suspended fiber.\nvar didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary\nvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete[\"return\"]=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the\n// siblings of a suspended node. The mismatch may be due to the missing\n// data, so it's probably a false positive.\nreturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\nnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n// This simplifies the code for getHostSibling and deleting nodes,\n// since it doesn't have to consider all Suspense boundaries and\n// check if they're dehydrated ones or not.\nvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment[\"return\"]=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n// it during the first pass. Instead, we'll reenter it later.\nnextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber[\"return\"];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent[\"return\"];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them. We also don't delete anything inside the root container.\nif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n// during the hydration attempt are now recovered. We will log them in\n// commit phase, once the entire tree has finished.\nqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){},discardPendingWarnings:function discardPendingWarnings(){}};{var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node[\"return\"];}return maybeStrictRoot;};var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\nvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\ninstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\nvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\nif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\nvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n// cannot be called outside the render phase.\ncurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\nvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node[\"return\"];}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber[\"return\"]=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\nif(dependency.context===context){// Match! Schedule an update on this fiber.\nif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\nvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n// update to the current fiber, too, which means it will persist even if\n// this render is thrown away. Since it's a race condition, not sure it's\n// worth fixing.\n// Inlined `enqueueUpdate` to remove interleaved update check\nvar updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,workInProgress);// Mark the updated lanes on the list, too.\nlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n// dependency list.\nbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n// if it will have any context consumers in it. The best we can do is\n// mark it as having updates.\nvar parentSuspense=fiber[\"return\"];if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n// because we want to schedule this fiber as having work\n// on its children. We'll use the childLanes on\n// this fiber to indicate that a context has changed.\nscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.\nnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber[\"return\"]=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling[\"return\"]=nextFiber[\"return\"];nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber[\"return\"];}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\nmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\ndependencies.firstContext=null;}}}}function _readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n// Unlike the class check below, it's not enforced in production for perf.\nif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\nlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.\nlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else{concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n// `pending` field and an `interleaved` field. When they are not null, they\n// point to the last node in a circular linked list. We need to append the\n// interleaved list to the end of the pending list by joining them into a\n// single, circular list.\nif(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushConcurrentUpdateQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards\n// compatibility and should always be accompanied by a warning.\nvar unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\nvar node=sourceFiber;var parent=sourceFiber[\"return\"];while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent[\"return\"];}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\nvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update\n// queue so we can process it immediately during the current render.\nvar pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering\n// this fiber. This is for backwards compatibility in the case where you\n// update a different component during render phase than the one that is\n// currently renderings (a pattern that is accompanied by a warning).\nreturn unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else{return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n// have finished. We can remove them from the shared queue, which represents\n// a superset of the actually pending lanes. In some cases we may entangle\n// more than we need to, but that's OK. In fact it's worse if we *don't*\n// entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n// phase. They should be discarded if the render is aborted. Therefore,\n// we should only put them on the work-in-progress queue, not the current one.\nvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\nvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n// we bail out on a parent fiber that then captures an error thrown by\n// a child. Since we want to append the update only to the work-in\n// -progress queue, we need to clone the updates. We usually clone during\n// processUpdateQueue, but that didn't happen in this case because we\n// skipped over the parent when we bailed out.\nvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\nvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\nif(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.\nnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\nvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\nreturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object\npartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\nvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\nvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n// and last so that it's non-circular.\nvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\nif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n// we need to transfer the updates to that queue, too. Because the base\n// queue is a singly-linked list with no cycles, we can append to both\n// lists and take advantage of structural sharing.\n// TODO: Pass `current` as argument\nvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\nvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\nif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\nvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n// from the original lanes.\nvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\nnewLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.\nif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\nnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n// callback again.\nupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new\n// pending updates to the end of the list and keep processing.\nvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n// unravel them when transferring them to the base queue.\nvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n// This should be fine because the only two other things that contribute to\n// expiration time are props and context. We're already in the middle of the\n// begin phase by the time we start processing the queue, so we've already\n// dealt with the props. Context in components that specify\n// shouldComponentUpdate is tricky; but we'll have to account for\n// that regardless.\nmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\nvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var fakeInternalInstance={};// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nvar emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\npartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\nvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\nshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(_typeof(_state)!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&_typeof(ctor.childContextTypes)!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\ncontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\nif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(_typeof(contextType)!=='object'){addendum=' However, it is set to a '+_typeof(contextType)+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\naddendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(_typeof(contextType)==='object'&&contextType!==null){context=_readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(_typeof(contextType)==='object'&&contextType!==null){instance.context=_readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n// both before and after `shouldComponentUpdate` has been called. Not ideal,\n// but I'm loath to refactor this function. This only happens for memoized\n// components so it's not that common.\nenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function warnForMissingKey(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child,returnFiber){if(child===null||_typeof(child)!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(_typeof(child._store)!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&_typeof(mixedRef)!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n// everyone, because the strict mode case will no longer be relevant\nif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n// because these cannot be automatically converted to an arrow function\n// using a codemod. Therefore, we don't have to warn about string refs again.\n!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, \"%s\", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\nvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=resolvedInst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.\nrefs=resolvedInst.refs={};}if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\n// instead.\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n// part of a list of children (arrays, iterators).\nnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent);existing[\"return\"]=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\nvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created[\"return\"]=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment);existing[\"return\"]=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created[\"return\"]=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2[\"return\"]=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3[\"return\"]=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(_typeof(child)!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n// See https://github.com/facebook/react/issues/12995\nif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\nnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing[\"return\"]=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing[\"return\"]=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\ndeleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created[\"return\"]=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4[\"return\"]=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=_typeof(newChild)==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nif(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\nreturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild[\"return\"]=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild[\"return\"]=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\nfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\nvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\nvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n// fallback. Otherwise, don't capture and bubble to the next boundary.\nvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\nreturn true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.\n{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n// keep track of whether it suspended or not.\nnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===row){return null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\nvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\nvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\nvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\nfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n// Retaining it forever may interfere with GC.\nif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\nvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\nvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\nvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n// It's unlikely their type would change as usually you define them inline.\nerror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,_typeof(deps));}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n// lol @ IE not supporting String#repeat\nwhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\nreturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n// passed inline.\nif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\nignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n// currentHook = null;\n// workInProgressHook = null;\n// didScheduleRenderPhaseUpdate = false;\n// localIdCounter = 0;\n// TODO Warn if no hooks are used at all during mount, then some are used during update.\n// Currently we will identify the update render as a mount because memoizedState === null.\n// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n// so memoizedState would be null during updates and mounts.\n{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n// but no stateful hooks have been used.\n// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n// This dispatcher does that.\nReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\nif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\nvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n// after first render to prevent infinite render phase updates.\nignorePreviousDependencies=false;}// Start over from the beginning of the list\ncurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\nhookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\nvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n// render. If this fires, it suggests that we incorrectly reset the static\n// flags in some other part of the codebase. This has happened before, for\n// example, in the SuspenseList implementation.\nif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n// and creates false positives. To make this work in legacy mode, we'd\n// need to mark fibers that commit in an incomplete state, somehow. For\n// now I'll disable the warning that most of the bugs that would trigger\n// it are either exclusive to concurrent mode or exist in both.\n(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n// localIdCounter = 0;\nif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n// Conceptually, it's part of the return value of renderWithHooks; it's only a\n// separate function to avoid using an array tuple.\nvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n// complete phase (bubbleProperties).\nif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n// phase, which we are now aborting. Remove the updates from the queues so\n// they do not persist to the next render. Do not remove updates from hooks\n// that weren't processed.\n//\n// Only reset the updates from the queue if it has a clone. If it does\n// not have a clone, that means it wasn't processed, and the updates were\n// scheduled before we entered the render phase.\nvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list\nworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n// render phase update. It assumes there is either a current hook we can\n// clone, or a work-in-progress hook from a previous render pass that we can\n// use as a base. When we reach the end of the base list, we must switch to\n// the dispatcher used for mounts.\nvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\nworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.\nif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.\nworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\nreturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\nvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\nvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n// We'll add them to the base queue.\nif(baseQueue!==null){// Merge the pending queue and the base queue.\nvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n// the future if we implement resuming, or some form of that.\nerror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\nvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n// TODO: Don't need to accumulate this. Instead, we can remove\n// renderLanes from the original lanes.\ncurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.\nif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\nif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n// we can use the eagerly computed state\nnewState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n// work-in-progress hook.\nvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\nqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n// priority because it will always be the same as the current\n// render's.\nvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n// the base state unless the queue is empty.\n// TODO: Not sure if this is the desired semantics, but it's what we\n// do for gDSFP. I can't remember why.\nif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\n//\n// We won't do this if we're hydrating server-rendered content, because if\n// the content is stale, it's already visible anyway. Instead we'll patch\n// it up in a passive effect.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nhook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\nmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n// this whenever subscribe, getSnapshot, or value changes. Because there's no\n// clean-up function, and we track the deps correctly, we can call pushEffect\n// directly, without storing any additional state. For the same reason, we\n// don't need to set a static flag, either.\n// TODO: We can move this to the passive phase once we add a pre-commit\n// consistency check. See the next comment.\nfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n// commit phase if there was an interleaved mutation. In concurrent mode\n// this can happen all the time, but even in synchronous mode, an earlier\n// effect may have mutated the store.\nif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n// checking whether we scheduled a subscription effect above.\nworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\ninst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n// have been in an event that fired before the passive effects, or it could\n// have been in a layout effect. In that case, we would have used the old\n// snapsho and getSnapshot values to bail out. We need to check one more time.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function handleStoreChange(){// The store changed. Check if the snapshot changed since the last time we\n// read from the store.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\nreturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\ninitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\nnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n// The react-debug-hooks package injects its own implementation\n// so that e.g. DevTools can display custom hook values.\n}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\nif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.\nhook.memoizedState=value;return value;}else{// This is a rerender during an update.\nvar prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the\n// previous value and spawn a deferred render to update it later.\nif(!objectIs(value,prevValue)){// Schedule a deferred render\nvar deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent\n// from the latest value. The name \"baseState\" doesn't really match how we\n// use it because we're reusing a state hook field instead of creating a\n// new one.\nhook.baseState=true;}// Reuse the previous value\nreturn prevValue;}else{// This is not an urgent update, so we can use the latest value regardless\n// of what it is. No need to defer it.\n// However, if we're currently inside a spawned render, then we need to mark\n// this as an update to prevent the fiber from bailing out.\n//\n// `baseState` is true when the current value is different from the rendered\n// value. The name doesn't really match how we use it because we're reusing\n// a state hook field instead of creating a new one.\nif(hook.baseState){// Flip this back to false.\nhook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.\nvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n// should do this in Fiber, too? Deferring this decision for now because\n// there's no other place to store the prefix except for an internal field on\n// the public createRoot object, which the fiber tree does not currently have\n// a reference to.\nvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\nid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n// that represents the position of this useId hook among all the useId\n// hooks for this fiber.\nvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.\nvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n// next state before entering the render phase. If the new state is the\n// same as the current state, we may be able to bail out entirely.\nvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n// it, on the update object. If the reducer hasn't changed by the\n// time we enter the render phase, then the eager state can be used\n// without calling the reducer again.\nupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n// It's still possible that we'll need to rebase this update later,\n// if the component re-renders for a different reason and by that\n// time the reducer has changed.\n// TODO: Do we still need to entangle transitions in this case?\nenqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.\n}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n// queue -> linked list of updates. After this render pass, we'll restart\n// and apply the stashed updates on top of the work-in-progress hook.\ndidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?\nfunction entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n// must have finished. We can remove them from the shared queue, which\n// represents a superset of the actually pending lanes. In some cases we\n// may entangle more than we need to, but that's OK. In fact it's worse if\n// we *don't* entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:_readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function warnInvalidContextAccess(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function warnInvalidHookAccess(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber[\"return\"];}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n// In this case, the return pointer is also cleared out,\n// so we won't be able to report the time spent in this Profiler's subtree.\nparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber[\"return\"];}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n// after we rerender. This is used as a helper in special cases\n// where we should count the work of multiple passes.\nvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return{value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n// `preventDefault()` in window `error` handler.\n// We record this information as an expando on the error.\nif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n// Ignore it and don't print the stack addendum.\n// This is handy for testing error boundaries without noise.\nreturn;}// The error is fatal. Since the silencing might have\n// been accidental, we'll surface it anyway.\n// However, the browser would have silenced the original error\n// so we'll print it first, and then print the stack addendum.\nconsole['error'](error);// Don't transform to our wrapper\n// For a more detailed description of this block, see:\n// https://github.com/facebook/react/pull/13384\n}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole['error'](combinedMessage);// Don't transform to our wrapper\n}else{}}catch(e){// This method must not throw, or React internal state will get messed up.\n// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n// we want to report this error outside of the normal stack as a last resort.\n// https://github.com/facebook/react/issues/13188\nsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromError is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n// then it needs to call setState to recover from errors.\n// If no state update is scheduled then the boundary will swallow the error.\nif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n//\n// The data might resolve before we have a chance to commit the fallback. Or,\n// in the case of a refresh, we'll never commit a fallback. So we need to\n// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n// try rendering the tree again.\n//\n// Only attach a listener if one does not already exist for the lanes\n// we're currently rendering (which acts like a \"thread ID\" here).\n//\n// We only need to do this in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\nthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n//\n// If the fallback does commit, we need to attach a different type of\n// listener. This one schedules an update on the Suspense boundary to turn\n// the fallback state off.\n//\n// Stash the wakeable on the boundary fiber so we can access it in the\n// commit phase.\n//\n// When the wakeable resolves, we'll attempt to render the boundary\n// again (\"retry\").\nvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\nvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n// boundary.\nnode=node[\"return\"];}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n// it captures the suspended \"exception\" and does a second (fallback) pass.\nif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n//\n// If the boundary is in legacy mode, we should *not*\n// suspend the commit. Pretend as if the suspended component rendered\n// null and keep rendering. When the Suspense boundary completes,\n// we'll do a second pass to render the fallback.\nif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n// when a React.lazy component is a direct child of a\n// Suspense boundary.\n//\n// Suspense boundaries are implemented as multiple fibers, but they\n// are a single conceptual unit. The legacy mode behavior where we\n// pretend the suspended fiber committed as `null` won't work,\n// because in this case the \"suspended\" fiber is the inner\n// Offscreen wrapper.\n//\n// Because the contents of the boundary haven't started rendering\n// yet (i.e. nothing in the tree has partially rendered) we can\n// switch to the regular, concurrent mode behavior: mark the\n// boundary with ShouldCapture and enter the unwind phase.\nsuspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n// But we shouldn't call any lifecycle methods or callbacks. Remove\n// all lifecycle effect tags.\nsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n// completed class component. For example, we should not call\n// componentWillUnmount if it is deleted.\nsourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,\n// since it's known to be in an inconsistent state. Use a force update to\n// prevent a bail out.\nvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to\n// indicate that it still has pending work.\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n// with the normal suspend path.\n//\n// After this we'll use a set of heuristics to determine whether this\n// render pass will run to completion or restart or \"suspend\" the commit.\n// The actual logic for this is spread out in different places.\n//\n// This first principle is that if we're going to suspend when we complete\n// a root, then we should also restart if we get an update or ping that\n// might unsuspend it, and vice versa. The only reason to suspend is\n// because you think you might want to restart before committing. However,\n// it doesn't make sense to restart only while in the period we're suspended.\n//\n// Restarting too aggressively is also not good because it starves out any\n// intermediate loading state. So we use heuristics to determine when.\n// Suspense Heuristics\n//\n// If nothing threw a Promise or all the same fallbacks are already showing,\n// then don't suspend/restart.\n//\n// If this is an initial render of a new tree of Suspense boundaries and\n// those trigger a fallback, then don't suspend/restart. We want to ensure\n// that we can show the initial loading state as quickly as possible.\n//\n// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n// a fallback, then we should always suspend/restart. Transitions apply\n// to this case. If none is defined, JND is used instead.\n//\n// If we're already showing a fallback and it gets \"retried\", allowing us to show\n// another level, but there's still an inner boundary that would show a fallback,\n// then we suspend/restart for 500ms since the last time we showed a fallback\n// anywhere in the tree. This effectively throttles progressive loading into a\n// consistent train of commits. This also gives us an opportunity to restart to\n// get to the completed state slightly earlier.\n//\n// If there's ambiguity due to batching it's resolved in preference of:\n// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n//\n// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n// ensure that new initial loading states can commit as soon as possible.\nsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n// the begin phase to prevent an early bailout.\nsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\nsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&_typeof(value)==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\nvar wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.\n// We can suspend and wait for more data to arrive.\nif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n// Suspense boundary, this will unwind all the way to the root without\n// performing a second pass to render a fallback. (This is arguably how\n// refresh transitions should work, too, since we're not going to commit\n// the fallbacks anyway.)\n//\n// This case also applies to initial hydration.\nattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n// because discrete renders are expected to produce a complete tree\n// synchronously to maintain consistency with external state.\nvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n// The error will be caught by the nearest suspense boundary.\nvalue=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.\nif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n// discarding the dehydrated content and switching to a client render.\n// Instead of surfacing the error, find the nearest Suspense boundary\n// and render it again without hydration.\nif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n// children again, not the fallback.\n_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n// still log it so it can be fixed.\nqueueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nvar workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress[\"return\"];}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n// want to reconcile without matching against the existing set. This has the\n// effect of all current children being unmounted; even if the type and key\n// are the same, the old child is unmounted and a new child is created.\n//\n// To do this, we're going to go through the reconcile algorithm twice. In\n// the first pass, we schedule a deletion for all the current children by\n// passing null.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n// pass null in place of where we usually pass the current child set. This has\n// the effect of remounting all children regardless of whether their\n// identities match.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens after the first render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\nvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\nComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n// and with only the default shallow comparison, we upgrade it\n// to a SimpleMemoComponent to allow fast path updates.\nworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(type));}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child[\"return\"]=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n// unlike current.memoizedProps which will be the unresolved ones.\nvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\nvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild[\"return\"]=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens when the inner render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n// so let's just skip over it to find memo() outer wrapper.\n// Inner props for memo are validated later.\nvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\nvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\nworkInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we\n// would during a normal fiber bailout.\n//\n// We don't have strong guarantees that the props object is referentially\n// equal during updates where we can't bail out anyway — like if the props\n// are shallowly equal, but there's a local state or context update in the\n// same batch.\n//\n// However, as a principle, we should aim to make the behavior consistent\n// across different ways of memoizing a component. For example, React.memo\n// has a different internal Fiber layout if you pass a normal function\n// component (SimpleMemoComponent) versus if you pass a different type\n// like forwardRef (MemoComponent). But this is an implementation detail.\n// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n// affect whether the props object is reused during a bailout.\nworkInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n// about to bail out, but there might be other lanes that weren't\n// included in the current render. Usually, the priority level of the\n// remaining updates is accumulated during the evaluation of the\n// component (i.e. when processing the update queue). But since since\n// we're bailing out early *without* evaluating the component, we need\n// to account for it here, too. Reset to the value of the current fiber.\n// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n// because a MemoComponent fiber does not have hooks or an update queue;\n// rather, it wraps around an inner component, which may or may not\n// contains hooks.\n// TODO: Move the reset at in beginWork out of the common path so that\n// this is no longer necessary.\nworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\nif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\n// TODO: Consider how Offscreen should work with transitions in the future\nvar nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n// and resume this tree later.\nvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\nworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\npushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already\n// committed. Now we resume rendering the hidden tree.\n// Rendering at offscreen, so we can clear the base lanes.\nvar _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\nvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.\nvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing\n// special to do. Need to push to the stack regardless, though, to avoid\n// a push/pop misalignment.\n_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold\nfunction updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\nswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n// Is there a better way to do this?\nvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\nvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\nvar update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\nmarkRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n// the existing children. Conceptually, the normal children and the children\n// that are shown on error are two different sets, so we shouldn't reuse\n// normal children even if their identities match.\nforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called \"element\".\nvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n// attempt to hydrate.\n// Flip isDehydrated to false to indicate that when this render\n// finishes, the root will no longer be dehydrated.\nvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n// have reducer functions so it doesn't need rebasing.\nupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n// forced a client render.\nvar recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.\nenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it\n// already hydrated.\nresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\nresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also has access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\nworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\nrenderLanes);return child;}}var hint='';{if(Component!==null&&_typeof(Component)==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n// because the fact that it's a separate type of work is an\n// implementation detail.\nthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.\nworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n// Whether or not it would crash later, we want to show a good message in DEV first.\nif(_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n// Eventually we'll delete this branch altogether.\n_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\nworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component\nworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(_typeof(Component.contextType)==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n// remain on that fallback regardless of whether the content has resolved.\n// For example, SuspenseList coordinates when nested content appears.\nif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n// Note: This is a factoring smell. Can't remain on a fallback if there's\n// no fallback to remain on.\nreturn false;}}// Not currently showing content. Consult the Suspense context.\nreturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\nreturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n// rendering the fallback children.\nshowFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content\nif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n// Mark this subtree context as having at least one invisible parent that could\n// handle the fallback state.\n// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n// boundary's children. This involves some custom reconciliation logic. Two\n// main reasons this is so complicated.\n//\n// First, Legacy Mode has different semantics for backwards compatibility. The\n// primary tree will commit in an inconsistent state, so when we do the\n// second pass to render the fallback, we do some exceedingly, uh, clever\n// hacks to make that not totally break. Like transferring effects and\n// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n// because we bailout on the primary tree completely and leave it in its old\n// state, no effects. Same as what we do for Offscreen (except that\n// Offscreen doesn't have the first render pass).\n//\n// Second is hydration. During hydration, the Suspense fiber has a slightly\n// different layout, where the child points to a dehydrated fragment, which\n// contains the DOM rendered by the server.\n//\n// Third, even if you set all that aside, Suspense is like error boundaries in\n// that we first we try to render one tree, and if that fails, we render again\n// and switch to a different tree. Like a try/catch block. So we have to track\n// which branch we're currently rendering. Ideally we would model this using\n// a stack.\nif(current===null){// Initial mount\n// Special path for hydration\n// If we're currently hydrating, try to hydrate this boundary.\ntryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\nvar suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.\n// Special path for hydration\nvar prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else{var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment[\"return\"]=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\nprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n// this wrapper function to constrain it.\nreturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n// wrapper function to constrain it.\nreturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\nvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\n(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n// already cloned. In legacy mode, the only case where this isn't true is\n// when DevTools forces us to display a fallback; we skip the first render\n// pass entirely and go straight to rendering the fallback. (In Concurrent\n// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n// only codepath.)\nworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.\n// However, since we're going to remain on the fallback, we no longer want\n// to delete it.\nworkInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.\n// (We don't do this in legacy mode, because in legacy mode we don't re-use\n// the current tree; see previous branch.)\nprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;}fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n// implications, it's considered a recoverable error, even though the user\n// likely won't observe anything wrong with the UI.\n//\n// The error is passed in as an argument to enforce that every caller provide\n// a custom message, or explicitly opt out (currently the only path that opts\n// out is legacy mode; every concurrent path provides an error).\nif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\nvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n// boundary) already mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n// deletion. We need to reconcile to delete the current child.\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n// Instead, we'll leave the content in place and try to hydrate it later.\nif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n// for this, we need to schedule that at a higher priority based on when it would\n// have timed out. In theory we could render it in this pass but it would have the\n// wrong priority associated with it and will prevent hydration of parent path.\n// Instead, we'll leave work left on it to render it in a separate commit.\n// TODO This time should be the time at which the server rendered response that is\n// a parent to this boundary was displayed. However, since we currently don't have\n// a protocol to transfer that time, we'll just estimate it by using the current\n// time. This will mean that Suspense timeouts are slightly shifted to later than\n// they should be.\n// Schedule a normal pri update to render this content.\nworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already\n// be showing the right content coming from the server, it is no rush.\nworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.\n// We should never be hydrating at this point because it is the first pass,\n// but after we've already committed once.\nwarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n// required — every concurrent mode path that causes hydration to\n// de-opt to client rendering should have an error message.\nnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n// get an update and we'll never be able to hydrate the final content. Let's just try the\n// client side render instead.\nvar digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(message);}else{error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.\nvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n// hydrate it. We might still be able to hydrate it using a higher priority lane.\nvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n// is one of the very rare times where we mutate the current tree\n// during the render phase.\nsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\nvar eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n// since we now have higher priority work, but in case it doesn't, we need to prepare to\n// render something, if we time out. Even if that requires us to delete everything and\n// skip hydration.\n// Delay having to do this as long as the suspense timeout allows us.\nrenderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n// content. We treat it as if this component suspended itself. It might seem as if\n// we could just try to render it client-side instead. However, this will perform a\n// lot of unnecessary work and is unlikely to complete since it often will suspend\n// on missing data anyway. Additionally, the server might be able to render more\n// than we can on the client yet. In that case we'd end up with more fallback states\n// on the client than if we just leave it alone. If the server times out or errors\n// these should update this boundary to the permanent Fallback state instead.\n// Mark it as having captured (i.e. suspended).\nworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\nworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\nvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.\nreenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else{// This is the second render pass. We already attempted to hydrated, but\n// something either suspended or errored.\nif(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\nworkInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n// Leave the existing child in place.\nworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n// but the normal suspense pass doesn't.\nworkInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.\n// Therefore we now have to render the fallback.\nvar nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n// If they were previously forced into fallbacks, they may now be able\n// to unblock.\nvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n// to schedule work on. In this case we have to schedule it on the\n// list itself.\n// We don't have to traverse to the children of the list since\n// the list will propagate the change when it rerenders.\nscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n// showing content on the screen, as opposed to being in fallback state or\n// new. If a row has multiple Suspense boundaries, any of them being in the\n// fallback state, counts as the whole row being in a fallback state.\n// Note that the \"rows\" will be workInProgress, but any nested children\n// will still be current since we haven't rendered them yet. The mounted\n// order may not be the same as the new order. We use the new order.\nvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.\nrenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n// on any nested boundaries to let them know to try to render\n// again. This is the same as context updating.\npropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n// use make it a noop by treating it as the default revealOrder.\nworkInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n// TODO: We could fast path by just rendering the tail now.\ntail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.\n// We're going to render them separately later.\ntail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\ntail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n// At the same time we're going to reverse the list of everything\n// we pass in the meantime. That's going to be our tail in reverse\n// order.\nvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\nworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\ninitSuspenseListRenderState(workInProgress,true,// isBackwards\n_tail,null,// last\ntailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\nnull,// tail\nnull,// last\nundefined);break;}default:{// The default reveal order is the same as not having\n// a boundary.\nworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule\n// them to update.\npropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n// DEV mode, we create a separate object for Context.Consumer that acts\n// like a proxy to Context. This proxy object adds unnecessary code in PROD\n// so we use the old behaviour (Context.Consumer references Context) to\n// reduce size and overhead. The separate object references context via\n// a property called \"_context\", which also gives us the ability to check\n// in DEV mode if this property exists or not and warn if it does not.\n{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n// Or it may be because it's older React where they're the same thing.\n// We only want to warn if we're sure it's a new React.\nif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=_readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\ncurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\nworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\nstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\nif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n// TODO: Once we add back resuming, we should check if the children are\n// a work-in-progress set. If so, we need to transfer their effects.\n{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n// fibers and continue.\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress[\"return\"];if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n// It will get deleted.\ncurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\nnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress[\"return\"]=oldWorkInProgress[\"return\"];newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\nif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n// Since the old fiber is disconnected, we have to schedule it manually.\nvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\nreturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n// updates or context.\nvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\nreturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n// the begin phase. There's still some bookkeeping we that needs to be done\n// in this optimized path, mostly pushing stuff onto the stack.\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\nvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n// been unsuspended it has committed as a resolved Suspense component.\n// If it needs to be retried, it should have work scheduled on it.\nworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\nreturn null;}// If this boundary is currently timed out, we need to decide\n// whether to retry the primary children, or to skip over it and\n// go straight to the fallback. Check the priority of the primary\n// child fragment.\nvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n// to attempt to render the primary children again.\nreturn updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked\n// on it\npushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n// priority. Bailout.\nvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n// primary children and work on the fallback.\nreturn child.sibling;}else{// Note: We can return `null` here because we already checked\n// whether there were nested context consumers, via the call to\n// `bailoutOnAlreadyFinishedWork` above.\nreturn null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n// same children then we're still in progressive loading state.\n// Something might get unblocked by state updates or retries in the\n// tree which will affect the tail. So we need to use the normal\n// path to compute the correct tail.\nreturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n// then the tail doesn't matter. Anything new that suspends will work\n// in the \"together\" mode, so we can continue from the state we had.\nvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n// update in the past but didn't complete it.\nrenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nreturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n// almost identical to the logic used in the normal update path,\n// so we'll just enter that. The only difference is we'll bail out\n// at the next level instead of this one, because the child props\n// have not changed. Which is fine.\n// TODO: Probably should refactor `beginWork` to split the bailout\n// path from the normal path. I'm tempted to do a labeled break here\n// but I won't :)\nworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\nreturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\nworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n// This may be unset if the props are determined to be equal later (memo).\ndidReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending\n// update or context change.\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n// may not be work scheduled on `current`, so we check for this flag.\n(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\ndidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props\n// nor legacy context. Set this to false. If an update queue or context\n// consumer produces a changed value, it will set this to true. Otherwise,\n// the component will assume the children have not changed and bail out.\ndidReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n// its parent.\n//\n// In a true multi-threaded implementation, we would render children on\n// parallel threads. This would represent the beginning of a new render\n// thread for this subtree.\n//\n// We only use this for id generation during hydration, which is why the\n// logic is located in this special branch.\nvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n// TODO: This assumes that we're about to evaluate the component and process\n// the update queue. However, there's an exception: SimpleMemoComponent\n// sometimes bails out later in the begin phase. This indicates that we should\n// move this assignment out of the common path and into each branch.\nworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\nvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode\nappendAllChildren=function appendAllChildren(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}};updateHostContainer=function updateHostContainer(current,workInProgress){// Noop\n};updateHostComponent$1=function updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n// we won't touch this node even if children changed.\nreturn;}// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function updateHostText$1(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n// so we don't leave any behind.\nreturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(lastTailNode===null){// All remaining items in the tail are insertions.\nrenderState.tail=null;}else{// Detach the insertion after the last node that was already\n// inserted.\nlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(_lastTailNode===null){// All remaining items in the tail are insertions.\nif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n// row at the tail. So we'll keep on and cut off the rest.\nrenderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already\n// inserted.\n_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n// When work is done, it should bubble to the parent's actualDuration. If\n// the fiber has not been cloned though, (meaning no work was done), then\n// this value will reflect the amount of time spent working on a previous\n// render. In that case it should not bubble. We determine whether it was\n// cloned by comparing the child pointer.\nactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child[\"return\"]=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child3[\"return\"]=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n// Suspense boundary, and also after we've reentered it for further hydration.\nif(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n// state since we're now exiting out of it. popHydrationState doesn't do that for us.\nresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\nworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n// as having hydrated so events know that they're free to be invoked.\n// It's also a signal to replay events and the suspense callback.\n// If something suspended, schedule an effect to attach retry listeners.\n// So we might as well always mark this.\nworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else{// Successfully completed this tree. If this was a forced client render,\n// there may have been recoverable errors during first hydration\n// attempt. If so, add them to a queue so we can log them in the\n// commit phase.\nupgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path\nreturn true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n// the commit side-effects on the root.\nmarkUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n// next commit. This handles the case of React rendering into a\n// container with previous children. It's also safe to do for\n// updates too, because current.child would only be null if the\n// previous render was null (so the container would already\n// be empty).\nworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n// recoverable errors during first hydration attempt. If so, add\n// them to a queue so we can log them in the commit phase.\nupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\nbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on whether we want to add them top->down or\n// bottom->up. Top->down is faster in IE11.\nvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this\n// to its own fiber type so that we can add other kinds of hydration\n// boundaries that aren't associated with a Suspense tree. In anticipation\n// of such a refactor, all the hydration logic is contained in\n// this branch.\nif(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat\n// this as a mismatch. Revert to client rendering.\nreturn workInProgress;}else{// Did not finish hydrating, either because this is the initial\n// render or because something suspended.\nreturn null;}}// Continue with the normal Suspense path.\n}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\nworkInProgress.lanes=renderLanes;// Do not reset the effect list.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\nreturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions\nif(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from\n// fallback -> primary, the inner Offscreen fiber schedules this effect\n// as part of its normal complete phase. But when we switch from\n// primary -> fallback, the inner Offscreen fiber does not have a complete\n// phase. So we need to schedule its effect here.\n//\n// We also use this flag to connect/disconnect the effects, but the same\n// logic applies: when re-connecting, the Offscreen fiber's complete\n// phase will handle scheduling the effect. It's only when the fallback\n// is active that we have to do anything special.\nif(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n// in the concurrent tree already suspended during this render.\n// This is a known bug.\nif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n// if this is a large tree which is common for initial loads. We\n// don't know if we should restart a render or not until we get\n// this marker, and this is too late.\n// If this render already had a ping or lower pri updates,\n// and this is the first time we know we're going to suspend we\n// should be able to immediately restart from within throwException.\nvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n// this boundary is ok.\nrenderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should\n// suspend for longer if possible.\nrenderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n// TODO: Move to passive phase\nworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\nvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n// sequential to ensure this switch is compiled to a jump table.\nvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n// We don't do anything in this mode.\nbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\nif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n// suspended in the rendered set.\n// If new content unsuspended, but there's still some content that\n// didn't. Then we need to do a second pass that forces everything\n// to keep showing their fallbacks.\n// We might be suspended if something in this render pass suspended, or\n// something in the previous committed pass suspended. Otherwise,\n// there's no chance so we can skip the expensive call to\n// findFirstSuspended.\nvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n// part of the second pass. In that case nothing will subscribe to\n// its thenables. Instead, we'll transfer its thenables to the\n// SuspenseList so that it can retry if they resolve.\n// There might be multiple of these in the list but since we're\n// going to wait for all of them anyway, it doesn't really matter\n// which ones gets to ping. In theory we could get clever and keep\n// track of how many dependencies remain but it gets tricky because\n// in the meantime, we can add/remove/change items and dependencies.\n// We might bail out of the loop before finding any but that\n// doesn't matter since that means that the other boundaries that\n// we did find already has their listeners attached.\nvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n// to stay in place.\n// Reset the effect flags before doing the second pass since that's now invalid.\n// Reset the child fibers to their original state.\nworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n// rerender the children.\npushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\nreturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n// left in the tail. We'll just give up further attempts to render\n// the main content and only render fallbacks.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n}else{// Append the rendered row to the child list.\nif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n// get lost if this row ends up dropped during a second pass.\nvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\nif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n){// We're done.\nbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n// time we have to render. So rendering one more row would likely\n// exceed it.\nnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n// attempts to render the main content and only render fallbacks.\n// The assumption is that this is usually faster.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n// to the end. This breaks the guarantee that life-cycles fire in\n// sibling order but that isn't a strong guarantee promised by React.\n// Especially since these might also just pop in during future commits.\n// Append to the beginning of the list.\nrenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n// Pop a row.\nvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n// TODO: We can probably just avoid popping it instead and only\n// setting it the first time we go from not suspended to suspended.\nvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n// Don't bubble properties in this case.\nreturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding — it only pre-renders.\n!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering\n// at offscreen priority.\nif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n// If so, we need to hide those nodes in the commit phase, so\n// schedule a visibility effect.\nif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{var root=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n// boundary. Do a second pass on the root to unmount the children.\nworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\nreturn null;}case HostComponent:{// TODO: popHydrationState\npopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n// caught by a nested boundary. If not, it should bubble through.\nreturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{var root=interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\nvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n// But we rely on it to surface errors to DEV tools like overlays\n// (https://github.com/facebook/react/issues/21712).\n// As a compromise, rethrow only caught errors in a guard.\n{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\nvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\nvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\nbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\nvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\nvar create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\nif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n// It does not get reset until the start of the next commit phase.\nvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n// After we process that Profiler, we'll bubble further up.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber[\"return\"];}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n// This is done to prevent sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\ncommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\nbreak;}case HostPortal:{// We have no life-cycles associated with portals.\nbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n// because the effect is also where times bubble to parent Profilers.\nenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n// Do not reset these values until the next render so DevTools has a chance to read them first.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber[\"return\"];}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n// TODO (Offscreen) Check: flags & LayoutStatic\nswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node[\"return\"],instance);}safelyAttachRef(node,node[\"return\"]);break;}case HostComponent:{safelyAttachRef(node,node[\"return\"]);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\nvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node[\"return\"];}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\nif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n// This enables us to detect and warn against state updates on an unmounted component.\n// It also prevents events from bubbling from within disconnected components.\n//\n// Ideally, we should also clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child.\n// This child itself will be GC:ed when the parent updates the next time.\n//\n// Note that we can't clear child or sibling pointers yet.\n// They're needed for passive effects and for findDOMNode.\n// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n//\n// Don't reset the alternate yet, either. We need that so we can detach the\n// alternate's fields in the passive phase. Clearing the return pointer is\n// sufficient for findDOMNode semantics.\nvar alternate=fiber.alternate;if(alternate!==null){alternate[\"return\"]=null;}fiber[\"return\"]=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n// `deletedTreeCleanUpLevel` is undefined.\n{// Clear cyclical Fiber fields. This level alone is designed to roughly\n// approximate the planned Fiber refactor. In that world, `setState` will be\n// bound to a special \"instance\" object instead of a Fiber. The Instance\n// object will not have any of these fields. It will only be connected to\n// the fiber tree via a single link at the root. So if this level alone is\n// sufficient to fix memory issues, that bodes well for our plans.\nfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n// tree, which has its own pointers to children, parents, and siblings.\n// The other host nodes also point back to fibers, so we should detach that\n// one, too.\nif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n// already disconnect the `return` pointer at the root of the deleted\n// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n// cyclical — it's only cyclical when combined with `child`, `sibling`, and\n// `alternate`. But we'll clear it in the next level anyway, just in case.\n{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n// disconnected the fiber from the tree. So even if something leaks this\n// particular fiber, it won't leak anything else\n//\n// The purpose of this branch is to be super aggressive so we can measure\n// if there's any difference in memory impact. If there is, that could\n// indicate a React leak we don't know about.\nfiber[\"return\"]=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\nfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber[\"return\"];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent[\"return\"];}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\n// TODO: Find a more efficient way to do this.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node[\"return\"]===null||isHostParent(node[\"return\"])){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.flags&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child[\"return\"]=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.flags&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\nswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\ninsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\ndefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a\n// deleted subtree.\n// TODO: Update these during the whole mutation phase, not just during\n// a deletion.\nvar hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its\n// children to find all the terminal nodes.\n// Recursively delete all host nodes from the parent, detach refs, clean\n// up mounted layout effects, and call componentWillUnmount.\n// We only need to remove the topmost host child in each branch. But then we\n// still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n// could split this into two separate traversals functions, where the second\n// one doesn't include any removeChild logic. This is maybe the same\n// function as \"disappearLayoutEffects\" (or whatever that turns into after\n// the layout phase is refactored to use recursion).\n// Before starting, find the nearest host parent on the stack so we know\n// which instance/container to remove the children from.\n// TODO: Instead of searching up the fiber return path on every deletion, we\n// can track the nearest host component on the JS stack as we traverse the\n// tree during the commit phase. This would make insertions faster, too.\nvar parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent[\"return\"];}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects\nvar child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse\n// into their subtree. There are simpler cases in the inner switch\n// that don't modify the stack.\nswitch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch\n}// eslint-disable-next-line-no-fallthrough\ncase HostText:{// We only need to remove the nearest host child. Set the host parent\n// to `null` on the stack to indicate that nested children don't\n// need to be removed.\n{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the\n// node from the tree.\nif(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else{removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.\n{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else{clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.\nvar _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else{safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag\ndeletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before\n// deleting the children, track that it's already unmounted so that we\n// don't attempt to unmount the effects again.\n// TODO: If the tree is hidden, in most cases we should be able to skip\n// over the nested children entirely. An exception is we haven't yet found\n// the topmost host node to delete, which we already track on the stack.\n// But the other case is portals, which need to be detached no matter how\n// deeply they are nested. We should use a subtree flag to track whether a\n// subtree includes a nested portal.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\nvar newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n// For each wakeable, attach a listener so that when it resolves, React\n// attempts to re-render the boundary in the primary (pre-timeout) state.\nvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\nvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\nrestorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen\n// before the children effects hae fired.\nvar deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,\n// because the fiber tag is more specific. An exception is any flag related\n// to reconcilation, because those can be set on all fiber types.\nswitch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork[\"return\"]);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}// Layout effects are destroyed during the mutation phase so that all\n// destroy functions for all fibers are called before any create functions.\n// This prevents sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}recordLayoutEffectDuration(finishedWork);}else{try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current[\"return\"]);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current[\"return\"]);}}{// TODO: ContentReset gets cleared by the children during the commit\n// phase. This is a refactor hazard because it means we must read\n// flags the flags after `commitReconciliationEffects` has already run;\n// the order matters. We should refactor so that ContentReset does not\n// rely on mutating the flag during commit. Like by setting a flag\n// during the render phase instead.\nif(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can\n// read it during an event\noffscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\nmarkCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag\nfinishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this\n// offscreen subtree was already hidden, so that we don't unmount the\n// effects again.\nvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else{recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can\n// read it during an event\n_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update\n// inside a hidden Offscreen tree.\nhideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber\n// type. They needs to happen after the children effects have fired, but\n// before the effects on this fiber have fired.\nvar flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork[\"return\"],error);}// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted does\n// and isMounted is deprecated anyway so we should be able to kill this.\nfinishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\nvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\nvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\ncommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\nvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\noffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n// back on.\nnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\nroot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\nnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\nsafelyDetachRef(fiber,fiber[\"return\"]);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber[\"return\"]);break;}case OffscreenComponent:{// Check if this is a\nvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n// its effects.\ndisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\nreappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nfirstChild[\"return\"]=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\nsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nsibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n// the previous (alternate) parent fiber's list of children. Because\n// children are a linked list, an earlier sibling that's still alive\n// will be connected to the deleted fiber via its `alternate`:\n//\n//   live fiber\n//   --alternate--> previous live fiber\n//   --sibling--> deleted fiber\n//\n// We can't disconnect `alternate` on nodes that haven't been deleted\n// yet, but we can disconnect the `sibling` and `child` pointers.\nvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n// TODO: Check if fiber has a PassiveStatic flag\nsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\nif(child!==null){child[\"return\"]=fiber;nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber[\"return\"];{// Recursively traverse the entire deleted tree and clean up fiber fields.\n// This is more aggressive than ideal, and the long term goal is to only\n// have to detach the deleted tree at the root.\ndetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling[\"return\"]=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber[\"return\"]);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber[\"return\"]);}catch(error){captureCommitPhaseError(fiber,fiber[\"return\"],error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol[\"for\"]){var symbolFor=Symbol[\"for\"];COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n// act environment whenever `jest` is defined, but you can still turn off\n// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n// to false.\nvar isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\nvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\nerror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\nvar executionContext=NoContext;// The root we're working on\nvar workInProgressRoot=null;// The fiber we're working on\nvar workInProgress=null;// The lanes we're rendering\nvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\nvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\nvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nvar workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\nvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\nvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\nvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nvar RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\nreturn now();}// We're not inside React, so we may be in the middle of a browser event.\nif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\nreturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\ncurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n// old behavior is to give this the same \"thread\" (lanes) as\n// whatever is currently rendering. So if you call `setState` on a component\n// that happens later in the same render, it will flush. Ideally, we want to\n// remove the special case and treat them as if they came from an\n// interleaved event. Regardless, this pattern is not officially supported.\n// This behavior is only a fallback. The flag only exists until we can roll\n// out the setState warning, since existing code might accidentally rely on\n// the current behavior.\nreturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n// updates at the same priority within the same event. To do this, the\n// inputs to the algorithm must be the same.\n//\n// The trick we use is to cache the first of each of these inputs within an\n// event. Then reset the cached values once we can be sure the event is\n// over. Our heuristic for that is whenever we enter a concurrent work loop.\nif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\ncurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n// their priority set by tracking it with a context variable.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n// appropriate priority, based on the type of event.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n// \"retries\" — a special update that attempts to flip a Suspense boundary\n// from its placeholder state to its primary/resolved state.\n// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.\nmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n// if the update originates from user space (with the exception of local\n// hook updates, which are handled differently and don't reach this\n// function), but there are some internal React features that use this as\n// an implementation detail, like selective hydration.\nwarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n}else{// This is a normal update, scheduled from outside the render phase. For\n// example, during an input event.\n{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark\n// that there was an interleaved update work on this root. Unless the\n// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n// phase update. In that case, we don't treat render phase updates as if\n// they were interleaved, for backwards compat reasons.\nif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n// definitely won't finish. Since we have a new update, let's mark it as\n// suspended now, right before marking the incoming update. This has the\n// effect of interrupting the current render and switching to the update.\n// TODO: Make sure this doesn't override pings that happen while we've\n// already started rendering.\nmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n// scheduleCallbackForFiber to preserve the ability to schedule a callback\n// without immediately flushing it. We only do this for user-initiated\n// updates, to preserve historical behavior of legacy mode.\nresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n// schedule the initial hydration of a root that has just been created. Most\n// of the stuff in scheduleUpdateOnFiber can be skipped.\n//\n// The main reason for this separate path, though, is to distinguish the\n// initial children from subsequent updates. In fully client-rendered roots\n// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n// updates, but hydration roots are special because the initial render must\n// match what was rendered on the server.\nvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,\n// which special (deprecated) behavior for UNSAFE_componentWillReceive props.\nreturn(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n// decided not to enable it.\n(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n// expired so we know to work on those next.\nmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\nvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\nif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\nvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\nvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n// on the `act` queue.\n!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n// Assume that discrete update microtasks are non-cancellable and null.\n// TODO: Temporary until we confirm this warning is not fired.\nif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\nreturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\ncancelCallback$1(existingCallbackNode);}// Schedule a new callback.\nvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n// internal queue\nif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\nif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n// at the end of the current scope even when using the sync version\n// of `act`.\nReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n// https://github.com/facebook/react/issues/22459\n// We don't support running callbacks in the middle of render\n// or commit so we need to check against that.\nif((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks\n// if this happens outside render or commit phase (e.g. in an event).\nflushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n// event time. The next update will compute a new event time.\ncurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n// in case they schedule additional work.\nvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n// Check if the task node for this root was changed.\nif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n// `ensureRootIsScheduled` because the check above implies either that\n// there's a new task, or that there's no remaining work on this root.\nreturn null;}}// Determine the next lanes to work on, using the fields stored\n// on the root.\nvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\nreturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n// for too long (\"expired\" work, to prevent starvation), or we're in\n// sync-updates-by-default mode.\n// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n// bug we're still investigating. Once the bug in Scheduler is fixed,\n// we can remove this, since we track expiration ourselves.\nvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n// render synchronously to block concurrent data mutations, and we'll\n// includes all pending updates are included. If it still fails after\n// the second attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n// cases where need to exit the current render without producing a\n// consistent tree or committing.\n//\n// This should only happen during a concurrent render, not a discrete or\n// synchronous update. We should have already checked for this when we\n// unwound the stack.\nmarkRootSuspended$1(root,lanes);}else{// The render completed.\n// Check if this render may have yielded to a concurrent event, and if so,\n// confirm that any newly rendered stores are consistent.\n// TODO: It's possible that even a concurrent render may never have yielded\n// to the main thread, if it was fast enough, or if it expired. We could\n// skip the consistency check in that case, too.\nvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n// synchronously, to block further mutations.\nexitStatus=renderRootSync(root,lanes);// We need to check again if something threw\nif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n// concurrent events.\n}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n// or, if something suspended, wait to commit it after a timeout.\nroot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n// currently executed. Need to return a continuation.\nreturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n// back to client side render.\n// Before rendering again, save the errors from the previous attempt.\nvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n// during the next attempt. To do this, we call prepareFreshStack now\n// to create the root work-in-progress fiber. This is a bit weird in terms\n// of factoring, because it relies on renderRootSync not calling\n// prepareFreshStack again in the call below, which happens because the\n// root and lanes haven't changed.\n//\n// TODO: I think what we should do is set ForceClientRender inside\n// throwException, like we do for nested Suspense boundaries. The reason\n// it's here instead is so we can switch to the synchronous work loop, too.\n// Something to consider for a future refactor.\nvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n// The errors from the failed first attempt have been recovered. Add\n// them to the collection of recoverable errors. We'll log them in the\n// commit phase.\nvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n// from the first attempt, to preserve the causal sequence.\nif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n// statement, but eslint doesn't know about invariant, so it complains\n// if I do. eslint-disable-next-line no-fallthrough\ncase RootErrored:{// We should have already attempted to retry this tree. If we reached\n// this point, it errored again. Commit it.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n// should immediately commit it or wait a bit.\nif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n// retries so that we don't show too many loading states too quickly.\nvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\nif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\nbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n// suspended level. Ping the last suspended level to try\n// rendering it again.\n// FIXME: What if the suspended lanes are Idle? Should not restart.\nvar eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n// lower priority work to do. Instead of committing the fallback\n// immediately, wait for more data to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n// placeholder and without scheduling a timeout. Delay indefinitely\n// until we receive more data.\nbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n// Schedule a placeholder to display after a short delay, using the Just\n// Noticeable Difference.\n// TODO: Is the JND optimization worth the added complexity? If this is\n// the only reason we track the event time, then probably not.\n// Consider removing.\nvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\nif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n// to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.\ncommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n// stores were mutated in a concurrent event. Intentionally using an iterative\n// loop instead of recursion so we can exit early.\nvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\nreturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n// a re-render, and the error will be rethrown during render.\nreturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child[\"return\"]=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return true;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n// eslint-disable-next-line no-unreachable\nreturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n// rarely, since we try to avoid it) updated during the render phase.\n// TODO: Lol maybe there's a better way to factor this besides this\n// obnoxiously named function :)\nsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\nensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n// synchronously to block concurrent data mutations, and we'll includes\n// all pending updates are included. If it still fails after the second\n// attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n// will commit it even if something suspended.\nvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next\n// pending level.\nensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n// most batchedUpdates-like method.\nif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n// next event, not at the end of the previous one.\nif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n// Note that this will happen even if batchedUpdates is higher up\n// the stack.\nif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n// the wrong context.\nreturn(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n// state. Now that we have additional work, cancel the timeout.\nroot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\ncancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress[\"return\"];while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork[\"return\"];}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\nresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n// separate issue. Write a regression test using string refs.\nReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork[\"return\"]===null){// Expected to be working on a non-root fiber. This is a fatal error\n// because there's no ancestor that can handle it; the root is\n// supposed to capture all errors that weren't caught by an error\n// boundary.\nworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n// sibling, or the parent if there are no siblings. But since the root\n// has no siblings nor a parent, we set it to null. Usually this is\n// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n// intentionally not calling those, we need set it here.\n// TODO: Consider calling `unwindWork` to pop the contexts.\nworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n// avoids inaccurate Profiler durations in the case of a\n// suspended render.\nstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&_typeof(thrownValue)==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork[\"return\"],erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\nthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n// the error. Bubble it to the next boundary.\nerroredWork=erroredWork[\"return\"];workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.\nreturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n// Instead the first renderer will lazily attach one, in order to give\n// nicer error messages.\nreturn ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n// this render.\nif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n// the updates that were skipped. Usually we only suspend at the end of\n// the render phase.\n// TODO: We should probably always mark the root as suspended immediately\n// (inside this function), since by suspending at the end of the render\n// phase introduces a potential mistake where we suspend lanes that were\n// pinged or updated while we were rendering.\nmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n// so those are false.\nreturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\nthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\nwhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n{markRenderYielded();}return RootInProgress;}else{// Completed the tree.\n{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\nreturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\nwhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\ncompleteUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n// sibling. If there are no more siblings, return to the parent fiber.\nvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=completedWork.alternate;var returnFiber=completedWork[\"return\"];// Check if the work completed or if something threw.\nif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\nworkInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\nif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\nvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\nreturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.\nworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\ncompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\nworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\nif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and\n// layout phases. Should be able to remove.\nvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n// means `flushPassiveEffects` will sometimes result in additional\n// passive effects. So we need to keep flushing in a loop until there are\n// no more pending effects.\n// TODO: Might be better if `flushPassiveEffects` did not automatically\n// flush synchronous work at the end, to avoid factoring hazards like this.\nflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n// So we can clear these now to allow a new callback to be scheduled.\nroot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n// pending time is whatever is left on the root fiber.\nvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\nworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n// Do this as early as possible, so it is queued before anything else that\n// might get scheduled in the commit phase. (See #16714.)\n// TODO: Delete all other places that schedule the passive effect callback\n// They're redundant.\nif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed\n// We need to pass this through as an argument to commitRoot\n// because workInProgressTransitions might have changed between\n// the previous render and commit if we throttle the commit\n// with setTimeout\npendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n// *after* passive effects fire to avoid freeing a cache pool that may\n// be referenced by a node in the tree (HostRoot, Cache boundary etc)\nreturn null;});}}// Check if there are any effects in the whole tree.\n// TODO: This is left over from the effect list implementation, where we had\n// to check for the existence of `firstEffect` to satisfy Flow. I think the\n// only other reason this optimization exists is because it affects profiling.\n// Reconsider whether this is necessary.\nvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\nReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n// of the effect list for each phase: all mutation effects come before all\n// layout effects, and so on.\n// The first phase a \"before mutation\" phase. We use this phase to read the\n// state of the host tree right before we mutate it. This is where\n// getSnapshotBeforeUpdate is called.\nvar shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n// batch. This enables them to be grouped later.\nrecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the mutation phase, so that the previous tree is still current during\n// componentWillUnmount, but before the layout phase, so that the finished\n// work is current during componentDidMount/Update.\nroot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\nrequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\nsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.\nroot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n// no effects.\n// TODO: Maybe there's a better way to report this.\n{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n// schedule a callback until after flushing layout work.\nrootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else{{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it\nremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n// is to detect whether something might have called setState inside\n// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n// inside `componentDidCatch` is itself flawed — that's why we recommend\n// `getDerivedStateFromError` instead. However, it could be improved by\n// checking if remainingLanes includes Sync work, instead of whether there's\n// any work remaining at all (which would also include stuff like Suspense\n// retries or transitions). It's been like this for a while, though, so fixing\n// it probably isn't that urgent.\nif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n// additional work on this root is scheduled.\nensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n// needing to surface it to the UI. We log them here.\nvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n// synchronously at the end of the current task so that the result is\n// immediately observable. Otherwise, we assume that they are not\n// order-dependent and do not need to be observed by external systems, so we\n// can wait until after paint.\n// TODO: We can optimize this by not scheduling the callback earlier. Since we\n// currently schedule the callback in multiple places, will wait until those\n// are consolidated.\nif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\nremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n// finishing. If there are too many, it indicates an infinite update loop.\nif(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\nflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n// probably just combine the two functions. I believe they were only separate\n// in the first place because we used to wrap it with\n// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n// priority within React itself, so we can mutate the variable directly.\nif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag\nvar transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n// Figure out why and fix it. It's not causing any known issues (probably\n// because it's only used for profiling), but it's a refactor hazard.\npendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects\n{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this\n// exceeds the limit, we'll fire a warning.\nif(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else{nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects\nonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\ncaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber[\"return\"];}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n// will fire for errors that are thrown by destroy functions inside deleted\n// trees. What it should instead do is propagate the error to the parent of\n// the deleted tree. In the meantime, do not add this warning to the\n// allowlist; this is only for our internal use.\nerror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\npingCache[\"delete\"](wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n// rendering. We might want to restart this render. This should mirror\n// the logic of whether or not a root suspends once it completes.\n// TODO: If we're rendering sync either due to Sync, Batched or expired,\n// we should probably never restart.\n// If we're suspended with delay, or if it's a retry, we'll always suspend\n// so we can always restart.\nif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\nprepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an\n// opportunity later. So we mark this render as having a ping.\nworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n// previously was rendered in its fallback state. One of the promises that\n// suspended it has resolved, which means at least part of the tree was\n// likely unblocked. Try rendering again, at a new lanes.\nif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n// unnecessary entanglement?\nretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\nvar eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\nvar retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\nretryCache[\"delete\"](wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n// Maybe not a big deal since this is DEV only behavior.\nsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current[\"return\"];}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\nreturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\nreturn;}// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function beginWork$1(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n// dispatched event, so that the debugger will treat it as an uncaught\n// error See ReactErrorUtils for more information.\n// Before entering the begin phase, copy the work-in-progress onto a dummy\n// fiber. If beginWork throws, we'll use this to reset the state.\nvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&_typeof(originalError)==='object'&&typeof originalError.then==='function'){// Don't replay promises.\n// Don't replay errors if we are hydrating and have already suspended or handled an error\nthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n// corresponding changes there.\nresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n// same fiber again.\n// Unwind the failed stack frame\nunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\nassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\nstartProfilerTimer(unitOfWork);}// Run beginWork again.\ninvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(_typeof(replayError)==='object'&&replayError!==null&&replayError._suppressLogging&&_typeof(originalError)==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\noriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\nthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\nvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n// Those may still be relevant to the current commit\n// and a future one (e.g. Suspense).\n}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n// the `act` queue instead.\nvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\nreturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\nreturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}}else{// Legacy mode has additional cases where we suppress a warning.\nif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n// batchedUpdates or flushSync.\nreturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n// warns for updates that originate from a hook.\nreturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nvar failedBoundaries=null;var setRefreshHandler=function setRefreshHandler(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\nreturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\nreturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\nif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n// but it's possible that we only have its inner render function in the map.\n// If that inner render function is different, we'll build a new forwardRef type.\nvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\nreturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\nvar needsCompareFamilies=false;var $$typeofNextType=_typeof(nextType)==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n// We're going to assume that the lazy inner type is stable,\n// and so it is sufficient to avoid reconciling it away.\n// We're not going to unwrap or actually use the new lazy type.\nneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n// we shouldn't set this.\nneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\nif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n// This means both of them need to be registered to preserve state.\n// If we unwrapped and compared the inner types for wrappers instead,\n// then we would risk falsely saying two separate memo(Foo)\n// calls are equivalent because they wrap the same Foo function.\nvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function scheduleRefresh(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function scheduleRoot(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n// but we don't know the parentComponent so we can't pass it.\n// Just ignore. We'll delete this with _renderSubtree code path later.\nreturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function findHostInstancesForRefresh(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n// There's no need to search deeper because for the purpose of giving\n// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\nfindHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.\nif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\nvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node[\"return\"]===null){throw new Error('Expected to reach root first.');}node=node[\"return\"];}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\nfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===fiber){return foundHostInstances;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\nthis[\"return\"]=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\nthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n//\n// Initializing the fields below to smis and later updating them with\n// double values will cause Fibers to end up having separate shapes.\n// This behavior/bug has something to do with Object.preventExtension().\n// Fortunately this only impacts DEV builds.\n// Unfortunately it makes React unusably slow for some applications.\n// To work around this, initialize the fields below with doubles.\n//\n// Learn more about this here:\n// https://github.com/facebook/react/issues/14365\n// https://bugs.chromium.org/p/v8/issues/detail?id=8538\nthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n// This won't trigger the performance cliff mentioned above,\n// and it simplifies other profiler code (including DevTools).\nthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\nthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.flags=NoFlags;// The effects are no longer valid.\nworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n// Static effects are not specific to a render.\nworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\nfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n// have set the values to before during the first pass. Ideally this wouldn't\n// be necessary but unfortunately many code paths reads from the workInProgress\n// when they should be reading from current and writing to workInProgress.\n// We assume pendingProps, index, key, ref, return are still untouched to\n// avoid doing another reconciliation.\n// Reset the effect flags but keep any Placement tags, since that's something\n// that child fiber is setting, not the reconciliation.\nworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\nvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\nworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.\nworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n// This enables DevTools to start capturing timing at any point–\n// Without some nodes in the tree having empty base times.\nmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\nkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\nvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\nmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\ndefault:{if(_typeof(type)==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\nfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||_typeof(type)==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:_typeof(type))+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',_typeof(pendingProps.id));}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target[\"return\"]=source[\"return\"];target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\ntransitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.2.0';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n// render and there's another warning for that anyway.\nif(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\ncallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\nroot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n// a regular update because the initial render must match was was rendered\n// on the server.\n// NOTE: This update intentionally doesn't have a payload. We're only using\n// the update to schedule work on the root fiber (and, for legacy roots, to\n// enqueue the callback if one is provided).\nvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\nvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase\n// the priority of any promises resolving within this\n// boundary so that they next attempt also has higher pri.\nvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority and they should not suspend on I/O,\n// since you have to wrap anything that might suspend in\n// Suspense.\nreturn;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority other than synchronously flush it.\nreturn;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function shouldErrorImpl(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function shouldSuspendImpl(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function copyWithDeleteImpl(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\nupdated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function copyWithDelete(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function copyWithRenameImpl(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\nupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here\nupdated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here\nobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function copyWithRename(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function copyWithSetImpl(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\nupdated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function copyWithSet(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function findHook(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n// This may change in the future with e.g. nested hooks.\nvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\noverrideHookState=function overrideHookState(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function overrideHookStateDeletePath(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function overrideHookStateRenamePath(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\noverrideProps=function overrideProps(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function overridePropsDeletePath(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function overridePropsRenamePath(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function scheduleUpdate(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function setErrorHandler(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function setSuspenseHandler(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\nfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\ngetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n// which may not match for third party renderers.\nreconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n// emulating an uncaught JavaScript error.\nreportError:function(error){// In older browsers and test environments, fallback to console.error.\n// eslint-disable-next-line react-internal/no-production-logging\nconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(_typeof(options)==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n// the hydration callbacks.\nvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\nvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\nlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n// We only use it in places that are currently more relaxed.\nfunction isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n// legacy API.\n}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.\nvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\nflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\nroot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\nupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\nflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\ncontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\nreturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n// This is an array for better minification.\nEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\nconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}\n\n//# sourceURL=webpack://webpack-demo/./node_modules/react-dom/cjs/react-dom.development.js?");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n\n//# sourceURL=webpack://webpack-demo/./node_modules/react-dom/index.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var ReactVersion = '18.2.0';\n\n    // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n    var REACT_ELEMENT_TYPE = Symbol[\"for\"]('react.element');\n    var REACT_PORTAL_TYPE = Symbol[\"for\"]('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol[\"for\"]('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol[\"for\"]('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol[\"for\"]('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol[\"for\"]('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol[\"for\"]('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol[\"for\"]('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol[\"for\"]('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol[\"for\"]('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol[\"for\"]('react.memo');\n    var REACT_LAZY_TYPE = Symbol[\"for\"]('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol[\"for\"]('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {\n        return null;\n      }\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n      return null;\n    }\n\n    /**\n     * Keeps track of the current dispatcher.\n     */\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n    var ReactCurrentBatchConfig = {\n      transition: null\n    };\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n        if (impl) {\n          stack += impl() || '';\n        }\n        return stack;\n      };\n    }\n\n    // -----------------------------------------------------------------------------\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    }\n\n    // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          printWarning('warn', format, args);\n        }\n      }\n    }\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n          printWarning('error', format, args);\n        }\n      }\n    }\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n    var didWarnStateUpdateForUnmountedComponent = {};\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function isMounted(publicInstance) {\n        return false;\n      },\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var assign = Object.assign;\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (_typeof(partialState) !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function get() {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n    function ComponentDummy() {}\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true;\n\n    // an immutable object with a single mutable value\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n      if (displayName) {\n        return displayName;\n      }\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n      if (typeof type === 'string') {\n        return type;\n      }\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n            if (outerName !== null) {\n              return outerName;\n            }\n            return getComponentNameFromType(type.type) || 'Memo';\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n      return null;\n    }\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function warnAboutAccessingKey() {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function warnAboutAccessingRef() {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n      var propName; // Original props are copied\n\n      var props = assign({}, element.props); // Reserved names are extracted\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n        var defaultProps;\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n      var childrenLength = arguments.length - 2;\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n        props.children = childArray;\n      }\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (_typeof(element) === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n      return index.toString(36);\n    }\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = _typeof(children);\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n      var invokeCallback = false;\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n        }\n      }\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild,\n            // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + (\n            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?\n            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n          array.push(mappedChild);\n        }\n        return 1;\n      }\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n      return subtreeCount;\n    }\n\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n      return n;\n    }\n\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n      return children;\n    }\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null,\n        // Add these to use same hidden class in VM as ServerContext\n        _defaultValue: null,\n        _globalName: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function get() {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n              return context.Provider;\n            },\n            set: function set(_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function get() {\n              return context._currentValue;\n            },\n            set: function set(_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function get() {\n              return context._currentValue2;\n            },\n            set: function set(_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function get() {\n              return context._threadCount;\n            },\n            set: function set(_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function get() {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function get() {\n              return context.displayName;\n            },\n            set: function set(displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n            // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject[\"default\"];\n      } else {\n        throw payload._result;\n      }\n    }\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function get() {\n              return defaultProps;\n            },\n            set: function set(newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function get() {\n              return propTypes;\n            },\n            set: function set(newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : _typeof(render));\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    var REACT_MODULE_REFERENCE;\n    {\n      REACT_MODULE_REFERENCE = Symbol[\"for\"]('react.module.reference');\n    }\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n      if (_typeof(type) === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n      return false;\n    }\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : _typeof(type));\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    }\n\n    // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n    function disabledLog() {}\n    disabledLog.__reactDisabledLog = true;\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        disabledDepth++;\n      }\n    }\n    function reenableLogs() {\n      {\n        disabledDepth--;\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n        return '\\n' + prefix + name;\n      }\n    }\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n      {\n        var frame = componentFrameCache.get(fn);\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function Fake() {\n            throw Error();\n          }; // $FlowFixMe\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function set() {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n          if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n      return '';\n    }\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, _typeof(error$1));\n              setCurrentlyValidatingElement(null);\n            }\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n      return '';\n    }\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n    var ownerHasKeyUseWarning = {};\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n    function validateChildKeys(node, parentType) {\n      if (_typeof(node) !== 'object') {\n        return;\n      }\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n        var propTypes;\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (_typeof(type) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n        // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n        if (type === undefined || _typeof(type) === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n        var typeString;\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = _typeof(type);\n        }\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n      return element;\n    }\n    var didWarnAboutDeprecatedCreateFactory = false;\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function get() {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n      validatePropTypes(newElement);\n      return newElement;\n    }\n    function startTransition(scope, options) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = {};\n      var currentTransition = ReactCurrentBatchConfig.transition;\n      {\n        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n      }\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition === null && currentTransition._updatedFibers) {\n            var updatedFibersCount = currentTransition._updatedFibers.size;\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n            currentTransition._updatedFibers.clear();\n          }\n        }\n      }\n    }\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function enqueueTaskImpl(callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n      return enqueueTaskImpl(task);\n    }\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n        if (result !== null && _typeof(result) === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function then(resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n            var _thenable = {\n              then: function then(resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function then(resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n    var isFlushing = false;\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack://webpack-demo/./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n\n//# sourceURL=webpack://webpack-demo/./node_modules/react/index.js?");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nif (true) {\n  (function () {\n    'use strict';\n\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n    var enableSchedulerDebugging = false;\n    var enableProfiling = false;\n    var frameYieldMs = 5;\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      siftUp(heap, node, index);\n    }\n    function peek(heap) {\n      return heap.length === 0 ? null : heap[0];\n    }\n    function pop(heap) {\n      if (heap.length === 0) {\n        return null;\n      }\n      var first = heap[0];\n      var last = heap.pop();\n      if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n      }\n      return first;\n    }\n    function siftUp(heap, node, i) {\n      var index = i;\n      while (index > 0) {\n        var parentIndex = index - 1 >>> 1;\n        var parent = heap[parentIndex];\n        if (compare(parent, node) > 0) {\n          // The parent is larger. Swap positions.\n          heap[parentIndex] = node;\n          heap[index] = parent;\n          index = parentIndex;\n        } else {\n          // The parent is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function siftDown(heap, node, i) {\n      var index = i;\n      var length = heap.length;\n      var halfLength = length >>> 1;\n      while (index < halfLength) {\n        var leftIndex = (index + 1) * 2 - 1;\n        var left = heap[leftIndex];\n        var rightIndex = leftIndex + 1;\n        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n        if (compare(left, node) < 0) {\n          if (rightIndex < length && compare(right, left) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            heap[index] = left;\n            heap[leftIndex] = node;\n            index = leftIndex;\n          }\n        } else if (rightIndex < length && compare(right, node) < 0) {\n          heap[index] = right;\n          heap[rightIndex] = node;\n          index = rightIndex;\n        } else {\n          // Neither child is smaller. Exit.\n          return;\n        }\n      }\n    }\n    function compare(a, b) {\n      // Compare sort index first, then task id.\n      var diff = a.sortIndex - b.sortIndex;\n      return diff !== 0 ? diff : a.id - b.id;\n    }\n\n    // TODO: Use symbols?\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n    function markTaskErrored(task, ms) {}\n\n    /* eslint-disable no-var */\n\n    var hasPerformanceNow = (typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function';\n    if (hasPerformanceNow) {\n      var localPerformance = performance;\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      var initialTime = localDate.now();\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n    var taskQueue = [];\n    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      var timer = peek(timerQueue);\n      while (timer !== null) {\n        if (timer.callback === null) {\n          // Timer was cancelled.\n          pop(timerQueue);\n        } else if (timer.startTime <= currentTime) {\n          // Timer fired. Transfer to the task queue.\n          pop(timerQueue);\n          timer.sortIndex = timer.expirationTime;\n          push(taskQueue, timer);\n        } else {\n          // Remaining timers are pending.\n          return;\n        }\n        timer = peek(timerQueue);\n      }\n    }\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n      if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else {\n          var firstTimer = peek(timerQueue);\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n        }\n      }\n    }\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = false;\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n      isPerformingWork = true;\n      var previousPriorityLevel = currentPriorityLevel;\n      try {\n        if (enableProfiling) {\n          try {\n            return workLoop(hasTimeRemaining, initialTime);\n          } catch (error) {\n            if (currentTask !== null) {\n              var currentTime = exports.unstable_now();\n              markTaskErrored(currentTask, currentTime);\n              currentTask.isQueued = false;\n            }\n            throw error;\n          }\n        } else {\n          // No catch in prod code path.\n          return workLoop(hasTimeRemaining, initialTime);\n        }\n      } finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n      }\n    }\n    function workLoop(hasTimeRemaining, initialTime) {\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      currentTask = peek(taskQueue);\n      while (currentTask !== null && !enableSchedulerDebugging) {\n        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n          // This currentTask hasn't expired, and we've reached the deadline.\n          break;\n        }\n        var callback = currentTask.callback;\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          var continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = exports.unstable_now();\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n        currentTask = peek(taskQueue);\n      } // Return whether there's additional work\n\n      if (currentTask !== null) {\n        return true;\n      } else {\n        var firstTimer = peek(timerQueue);\n        if (firstTimer !== null) {\n          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n        return false;\n      }\n    }\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n        default:\n          priorityLevel = NormalPriority;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n      if (_typeof(options) === 'object' && options !== null) {\n        var delay = options.delay;\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n      } else {\n        startTime = currentTime;\n      }\n      var timeout;\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n          break;\n        case UserBlockingPriority:\n          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n          break;\n        case IdlePriority:\n          timeout = IDLE_PRIORITY_TIMEOUT;\n          break;\n        case LowPriority:\n          timeout = LOW_PRIORITY_TIMEOUT;\n          break;\n        case NormalPriority:\n        default:\n          timeout = NORMAL_PRIORITY_TIMEOUT;\n          break;\n      }\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        sortIndex: -1\n      };\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask);\n        // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n      return newTask;\n    }\n    function unstable_pauseExecution() {}\n    function unstable_continueExecution() {\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n    function unstable_getFirstCallbackNode() {\n      return peek(taskQueue);\n    }\n    function unstable_cancelCallback(task) {\n      // remove from the queue because you can't remove arbitrary nodes from an\n      // array based heap, only the first one.)\n\n      task.callback = null;\n    }\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n    var isMessageLoopRunning = false;\n    var scheduledHostCallback = null;\n    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n    // thread, like user events. By default, it yields multiple times per frame.\n    // It does not attempt to align with frame boundaries, since most tasks don't\n    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n    var frameInterval = frameYieldMs;\n    var startTime = -1;\n    function shouldYieldToHost() {\n      var timeElapsed = exports.unstable_now() - startTime;\n      if (timeElapsed < frameInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n      } // The main thread has been blocked for a non-negligible amount of time. We\n\n      return true;\n    }\n    function requestPaint() {}\n    function forceFrameRate(fps) {\n      if (fps < 0 || fps > 125) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n        return;\n      }\n      if (fps > 0) {\n        frameInterval = Math.floor(1000 / fps);\n      } else {\n        // reset the framerate\n        frameInterval = frameYieldMs;\n      }\n    }\n    var performWorkUntilDeadline = function performWorkUntilDeadline() {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n        // has been blocked.\n\n        startTime = currentTime;\n        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n        var hasMoreWork = true;\n        try {\n          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        } finally {\n          if (hasMoreWork) {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            schedulePerformWorkUntilDeadline();\n          } else {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          }\n        }\n      } else {\n        isMessageLoopRunning = false;\n      } // Yielding to the browser will give it a chance to paint, so we can\n    };\n    var schedulePerformWorkUntilDeadline;\n    if (typeof localSetImmediate === 'function') {\n      // Node.js and old IE.\n      // There's a few reasons for why we prefer setImmediate.\n      //\n      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n      // (Even though this is a DOM fork of the Scheduler, you could get here\n      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n      // https://github.com/facebook/react/issues/20756\n      //\n      // But also, it runs earlier which is the semantic we want.\n      // If other browsers ever implement it, it's better to use it.\n      // Although both of these would be inferior to native scheduling.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    } else if (typeof MessageChannel !== 'undefined') {\n      // DOM and Worker environments.\n      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        port.postMessage(null);\n      };\n    } else {\n      // We should only fallback here in non-browser environments.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    }\n    function requestHostCallback(callback) {\n      scheduledHostCallback = callback;\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n      }\n    }\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n    function cancelHostTimeout() {\n      localClearTimeout(taskTimeoutID);\n      taskTimeoutID = -1;\n    }\n    var unstable_requestPaint = requestPaint;\n    var unstable_Profiling = null;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_Profiling = unstable_Profiling;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_forceFrameRate = forceFrameRate;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_next = unstable_next;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack://webpack-demo/./node_modules/scheduler/cjs/scheduler.development.js?");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}\n\n//# sourceURL=webpack://webpack-demo/./node_modules/scheduler/index.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./app/index.css":
/*!*****************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./app/index.css ***!
  \*****************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `body {\r\n    background: #ccc;\r\n}`, \"\"]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://webpack-demo/./app/index.css?./node_modules/css-loader/dist/cjs.js??ruleSet%5B1%5D.rules%5B2%5D.use%5B1%5D");

/***/ }),

/***/ "./app/index.css":
/*!***********************!*\
  !*** ./app/index.css ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./index.css */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./app/index.css\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\n\n      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\n    \noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\nif (true) {\n  if (!_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n  var p;\n  for (p in a) {\n    if (isNamedExport && p === \"default\") {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n  for (p in b) {\n    if (isNamedExport && p === \"default\") {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (!a[p]) {\n      return false;\n    }\n  }\n  return true;\n};\n    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals;\n    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./index.css */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./app/index.css\",\n      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./index.css */ \"./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[2].use[1]!./app/index.css\");\n(function () {\n        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals, isNamedExport)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals;\n\n              update(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_2_use_1_index_css__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://webpack-demo/./app/index.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://webpack-demo/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === \"undefined\") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://webpack-demo/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement(\"style\");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://webpack-demo/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute(\"nonce\", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://webpack-demo/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = \"\";\n  if (obj.supports) {\n    css += \"@supports (\".concat(obj.supports, \") {\");\n  }\n  if (obj.media) {\n    css += \"@media \".concat(obj.media, \" {\");\n  }\n  var needLayer = typeof obj.layer !== \"undefined\";\n  if (needLayer) {\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += \"}\";\n  }\n  if (obj.media) {\n    css += \"}\";\n  }\n  if (obj.supports) {\n    css += \"}\";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== \"undefined\") {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === \"undefined\") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://webpack-demo/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://webpack-demo/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./app/src/assets/manzara.jpg":
/*!************************************!*\
  !*** ./app/src/assets/manzara.jpg ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"data:image/jpeg;base64,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YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQwIDc5LjE2MDQ1MSwgMjAxNy8wNS8wNi0wMTowODoyMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxOS0xMS0xMVQxMjoxMzoxMyswMzowMCIgeG1wOk1ldGFkYXRhRGF0ZT0iMjAxOS0xMS0xMVQxMjoxMzoxMyswMzowMCIgeG1wOk1vZGlmeURhdGU9IjIwMTktMTEtMTFUMTI6MTM6MTMrMDM6MDAiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTY0OTRjOTktODdjNC00YjRiLTg2OGEtOWZjOWU3ZTI3MmVjIiB4bXBNTTpEb2N1bWVudElEPSJhZG9iZTpkb2NpZDpwaG90b3Nob3A6YWM0YzZkOWQtYWRiOS1mYjRiLWJhN2UtNDA0YjIxM2IzYzY1IiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6YTUxZjA1ZDEtNGQ3MS00YTEzLTlkNDEtYWNiODg5Y2NkMWFkIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIGRjOmZvcm1hdD0iaW1hZ2UvanBlZyI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6YTUxZjA1ZDEtNGQ3MS00YTEzLTlkNDEtYWNiODg5Y2NkMWFkIiBzdEV2dDp3aGVuPSIyMDE5LTExLTExVDEyOjEzOjEzKzAzOjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKE1hY2ludG9zaCkiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjk2NDk0Yzk5LTg3YzQtNGI0Yi04NjhhLTlmYzllN2UyNzJlYyIgc3RFdnQ6d2hlbj0iMjAxOS0xMS0xMVQxMjoxMzoxMyswMzowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8cGhvdG9zaG9wOkRvY3VtZW50QW5jZXN0b3JzPiA8cmRmOkJhZz4gPHJkZjpsaT4wNzIxMjAxMTY0Rjg1QkQxQkIwQzJBRjU5NDUyNTlENTwvcmRmOmxpPiA8cmRmOmxpPjNBOENCMjczQ0I1QTJDN0U2OEMzQkNGOTQ3NjU2OEM1PC9yZGY6bGk+IDxyZGY6bGk+M0U2MDBEREREQzBCM0I5OTVGQjI2M0NERDZCQTE3N0E8L3JkZjpsaT4gPHJkZjpsaT40NDEzNjk3RDE0ODhCNTVFQTE5NTREMzRCQTZBN0YwQjwvcmRmOmxpPiA8cmRmOmxpPjQ2OTUwNjBFMzlDMTEzNDQzQ0RDMjFGRDE3MERGQTE4PC9yZGY6bGk+IDxyZGY6bGk+NDkxQTM5OEUwQUI0NUZFQjY3NjhFRkYwOEI4QTk3NTk8L3JkZjpsaT4gPHJkZjpsaT40RDEyQjg4RDAyODg2QTQ0QTU0QjJGMkY2QkM2MkQ4RDwvcmRmOmxpPiA8cmRmOmxpPjVCQzUwRUFBRjhCMkFDNkI0ODFDNDlCMDQwOUVBMkI1PC9yZGY6bGk+IDxyZGY6bGk+NjREMDVDQjdERjVBMTdDM0M2REEyMDZEOTNBQjRDNkQ8L3JkZjpsaT4gPHJkZjpsaT43Njg2QURFNkE3OTgwRERDMzQ5RTlEOTAzOUMyMzhDRDwvcmRmOmxpPiA8cmRmOmxpPjdEOEVGRTA1RTE2MjA5NUFCMDA3REE0MUU1NUFEQjVGPC9yZGY6bGk+IDxyZGY6bGk+ODYwNjg2QTMyMDMyMjQ0N0QxNjE4OTc1ODM1NDM3Qjg8L3JkZjpsaT4gPHJkZjpsaT44RTlFM0FBRTMwQUFCMTVGQTZDQTQyODA2ODY2NDlDRDwvcmRmOmxpPiA8cmRmOmxpPjkzRUNBODM4NTM4NzA1RUMzQTJCNkJGQTcxQzlGQkI2PC9yZGY6bGk+IDxyZGY6bGk+OTQxODgzOTExQzBFRTdEQ0Y0M0JDRkY2NzU4NDAwOEM8L3JkZjpsaT4gPHJkZjpsaT45NUUxQUZDMjhENjM2Mzc5NjkxNTI4MzJBQ0U1NDJCMzwvcmRmOmxpPiA8cmRmOmxpPkEyNDkwOTVFRDM0MjM4MkE1OEExMDI3RTE5RTdBQkMzPC9yZGY6bGk+IDxyZGY6bGk+QTMyMkIwQkRFMzc1ODlBNkEyNjM5ODA0MEM1NzNBRTk8L3JkZjpsaT4gPHJkZjpsaT5BRDJGMjVFNEUxMDA1MjVCRDFFNDYxRjg5RDI3MDA1RDwvcmRmOmxpPiA8cmRmOmxpPkFFMERFQzUwQTEzOENGMzM5ODlDMTU3MjNFNzcyRkEzPC9yZGY6bGk+IDxyZGY6bGk+QjhGQUI2RjJBRkZDNDQzRDgyMzVCRDFCRDBBM0I0M0U8L3JkZjpsaT4gPHJkZjpsaT5DNEYzNkYzNzg3QjcxRTBDMTM1ODJGQkQxMkUyREQyNTwvcmRmOmxpPiA8cmRmOmxpPkNDNzUzQkE4RUM0MDE2OUI4RURCNzdFRjg1RDAyMkZGPC9yZGY6bGk+IDxyZGY6bGk+RDE1MzM3NDZDOTNGNUY4MUFDMEM0MkJCRDQ1RkU3Q0M8L3JkZjpsaT4gPHJkZjpsaT5FNTYzRkI4OTY1NzQ1MjlDNkVBN0VBNTQ4MTJGQ0U2RTwvcmRmOmxpPiA8cmRmOmxpPkY2ODQ1NTY3Q0IyNjM2QkVFRDdGRDA0ODMwQjY2NEM5PC9yZGY6bGk+IDxyZGY6bGk+RjlGOTRBMEFFMDdDOTgwRjZEMTVBNzFCMzdEQTc5ODQ8L3JkZjpsaT4gPC9yZGY6QmFnPiA8L3Bob3Rvc2hvcDpEb2N1bWVudEFuY2VzdG9ycz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPD94cGFja2V0IGVuZD0idyI/Pv/iDFhJQ0NfUFJPRklMRQABAQAADEhMaW5vAhAAAG1udHJSR0IgWFlaIAfOAAIACQAGADEAAGFjc3BNU0ZUAAAAAElFQyBzUkdCAAAAAAAAAAAAAAABAAD21gABAAAAANMtSFAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEWNwcnQAAAFQAAAAM2Rlc2MAAAGEAAAAbHd0cHQAAAHwAAAAFGJrcHQAAAIEAAAAFHJYWVoAAAIYAAAAFGdYWVoAAAIsAAAAFGJYWVoAAAJAAAAAFGRtbmQAAAJUAAAAcGRtZGQAAALEAAAAiHZ1ZWQAAANMAAAAhnZpZXcAAAPUAAAAJGx1bWkAAAP4AAAAFG1lYXMAAAQMAAAAJHRlY2gAAAQwAAAADHJUUkMAAAQ8AAAIDGdUUkMAAAQ8AAAIDGJUUkMAAAQ8AAAIDHRleHQAAAAAQ29weXJpZ2h0IChjKSAxOTk4IEhld2xldHQtUGFja2FyZCBDb21wYW55AABkZXNjAAAAAAAAABJzUkdCIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAEnNSR0IgSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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\");\n\n//# sourceURL=webpack://webpack-demo/./app/src/assets/manzara.jpg?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 		} catch(e) {
/******/ 			module.error = e;
/******/ 			throw e;
/******/ 		}
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("85c3f285ab5d13383f88")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "webpack-demo:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		self["webpackHotUpdatewebpack_demo"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./app/index.js");
/******/ 	
/******/ })()
;